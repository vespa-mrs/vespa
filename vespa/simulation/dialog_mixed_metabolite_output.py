# Python modules

import os
import math
import xml.etree.cElementTree as ElementTree
from datetime import datetime

# 3rd party modules
import wx
import numpy as np
from nifti_mrs.create_nmrs import gen_nifti_mrs_hdr_ext
from nifti_mrs.hdr_ext import Hdr_Ext


# Our modules
import vespa.simulation.constants as constants
import vespa.simulation.util_simulation_config as util_simulation_config
import vespa.simulation.dialog_mixed_metabolite_designer as dialog_mixed_metabolite_designer
import vespa.simulation.auto_gui.mixed_metabolite_output as mixed_metabolite_output
import vespa.common.mrs_experiment as mrs_experiment
import vespa.common.util.ppm as util_ppm
import vespa.common.util.xml_ as util_xml
import vespa.common.util.time_ as util_time
import vespa.common.util.misc as util_misc
import vespa.common.util.config as util_config
import vespa.common.util.export as util_export
import vespa.common.util.generic_spectral as util_generic_spectral
import vespa.common.constants as common_constants
import vespa.common.wx_gravy.common_dialogs as common_dialogs
import vespa.common.wx_gravy.util as wx_util
import vespa.common.mrs_prior as mrs_prior
import vespa.common.mrs_prior_metabolite as mrs_prior_metabolite

from wx.lib.agw.floatspin import FloatSpin, EVT_FLOATSPIN, FS_LEFT, FS_RIGHT, FS_CENTRE, FS_READONLY
from vespa.common.wx_gravy.widgets.floatspin_multiplier.floatspin_multiplier_base import FloatSpinMultiplier
from vespa.common.constants import Deflate
from vespa.common.nifti_mrs_vespa import NIFTIOrient



PI = math.pi

# This is the number of places to the right of the decimal displayed when
# a dim is a floating point number.
_SIGNIFICANT_DIGITS = 6

_VESPA_FYI_COMMENT = """This file was generated by Vespa-Simulation. You \
can learn about and download Vespa here:
https://github.com/vespa-mrs/vespa/
"""

_DEFAULT_OUTPUT_FORMAT = constants.ThirdPartyExportTypes.ANALYSIS_PRIOR

# _OUTPUT_ABBREVIATION_DISALLOWED lists the characters that we don't allow in
# metab abbreviations. The only reason we have any restrictions is because
# the abbreviations become filenames in some formats and Windows disallows
# all of these characters in filenames. 
# ref: http://en.wikipedia.org/wiki/Filename#Reserved_characters_and_words
_OUTPUT_ABBREVIATION_DISALLOWED = ('/*?|<>"\\')

# The message displayed when a metab name isn't kosher.
_INVALID_ABBREVIATION_MESSAGE = """Sorry, the abbreviation "%s" contains characters that \
Simulation Mixed Output doesn't allow.

Please don't use the following characters: 
"""
_INVALID_ABBREVIATION_MESSAGE += _OUTPUT_ABBREVIATION_DISALLOWED


def _find_best_column_size(listctrl, column):
    # ListCtrls can be sized according to the header or the largest content
    # item. Sometimes sizing by the header means content gets clipped, and
    # sometimes the reverse happens. This function figures out which of the
    # two is larger and returns that.
    listctrl.SetColumnWidth(column, wx.LIST_AUTOSIZE)
    value_width = listctrl.GetColumnWidth(column)

    listctrl.SetColumnWidth(column, wx.LIST_AUTOSIZE_USEHEADER)
    header_width = listctrl.GetColumnWidth(column)

    return max(value_width, header_width)


def _make_basis(vals, metabs_dict, npts, sw, apod, broad, field, 
               resppm, singlet_flag=False):

    # This first section parses the vals dictionary to create
    # lists of values for ppm, areas and phases. This may be just
    # one metabolite's values or some mixture of them. 

    ppms   = np.array([],dtype='float')
    areas  = np.array([],dtype='float')
    phases = np.array([],dtype='float')

    mname  = vals["metabolite"]
    abbr   = vals["abbr"]
    scale  = vals["scale"]
    shift  = vals["shift"]
    ppmstr = vals["range_start"]
    ppmend = vals["range_end"]

    # formula is a tuple of metabolite name and scale
    # factors, or it is None if not a mixture
    formula = vals["mixture"]

    if not formula:             
        # single metabolite - apply global shift and scale
        #    values to the ppms and areas respectively
        tmp  = metabs_dict[mname]
        ppms   = tmp['ppms'] + shift
        areas  = tmp['areas'] * scale
        phases = tmp['phases']

    else:   
        # metabolite mixture - apply global shift and scale
        #    values as well as mixture scale value
        for mix in formula:
            tmp  = metabs_dict[mix[0]]
            ppms   = np.concatenate((ppms,  (tmp['ppms'] + shift)))
            areas  = np.concatenate((areas, (tmp['areas'] * scale * mix[1])))
            phases = np.concatenate((phases, tmp['phases']))

    # sort for ppmstr and ppmend values

    indx = ((ppms > ppmstr) & (ppms < ppmend)).nonzero()[0]
    if indx.size:
        ppms   = ppms[indx]
        areas  = areas[indx]
        phases = phases[indx]

    # LCModel can optionally add a singlet reference peak at 0.0 ppm

    if singlet_flag:
        ppms   = np.concatenate((ppms,   np.array([0.0])))
        areas  = np.concatenate((areas,  np.array([1.0])))
        phases = np.concatenate((phases, np.array([0.0])))        

    # Create basis functions for the metabolite
    
    td     = 1.0/float(sw)
    nhalf  = npts / 2
    hpp    = float(sw) / float(npts)
    const1 = field/hpp
    const2 = PI * 2 * hpp
    arr1   = np.ones(npts, dtype='float32')
    nlines = len(areas)
    xx     = (np.arange(npts, dtype='float32') % npts)/sw

    # create apodization function
    lshape = util_generic_spectral.apodize(xx, apod, broad)

    # convert freq(ppm)/phase(deg) to freq(hz)/phase(rad) 

    freq = (nhalf - (ppms - resppm) * const1)  # ppm2pts
    freq = freq * const2 * 1j
    freq = np.repeat(freq, npts).reshape(nlines,npts)
    phas = areas * np.exp(phases * common_constants.DEGREES_TO_RADIANS * 1j)
    phas = np.repeat(phas, npts).reshape(nlines,npts)  

    # calculate the FIDs for each line 

    xx = np.tile(xx, nlines)
    xx.shape = nlines, npts
    xx = freq * xx
    xx = phas * np.exp(xx) 

    # sum lines from each simulation into one apodized uber-FID

    xx  = xx[0:nlines,:].sum(axis=0)
    res = xx * lshape
    
    return res


def _write_lines(filename, lines, force_unix_newlines=False):
    """Given a filename and a list of lines, joins those lines into a
    newline-delimited string and writes it to filename. If the file 
    exists, it's truncated before writing.
    
    The strings in the list of lines are converted to Unicode before
    writing if they're not Unicode already. If any of the non-Unicode
    strings contain non-ASCII, the conversion will fail. See:
    
    https://vespa-mrs.github.io/vespa.io/development/project_dev/technical/ThePerilsOfStr.html?highlight=perils
    
    By default, files are written with newline characters appropriate to the
    current platform. That's CRLF (0x0d 0x0a) on Windows and LF (0x0a) 
    everywhere else. If the param force_unix_newlines is True, then this 
    function will write LF for line endings regardless of platform. 
    
    In practice, we leave force_unix_newlines at its default except when 
    generating LCModel files. Regardless of where they're generated,
    they're only used under *nix.
    """
    # Note that all_lines will be a Unicode string after this join() 
    # because anything returned from wx will be Unicode, and any 
    # non-Unicode string joined to a Unicode string is "promoted" to
    # Unicode. Atfer the join we explicitly force the Unicode string
    # to UTF-8 so that it will be safe for write().
    lines = "\n".join(lines)
    lines = lines.encode("utf-8")
    
    if (wx.Platform == "__WXMSW__") and not force_unix_newlines:
        lines = lines.replace("\n", "\r\n")
    
    open(filename, "wb").write(lines)


#------------------------------------------------------------------------------
# Note. GUI Architecture/Style
#
# Many of the GUI components in Vespa are designed using the WxGlade 
# application to speed up development times. The GUI components are designed
# interactively and users can preview the resultant window/panel/dialog, but
# while event functions can be specified, only stub functions with those 
# names are created. The WxGlade files (with *.wxg extensions) are stored in
# the 'wxglade' subdirectory. The ouput of their code generation are stored
# in the 'auto_gui' subdirectory. 
#
# To used these GUI classes, each one is inherited into a unique 'vespa'
# class, where program specific initialization and other functionality are
# written.  Also, the original stub functions for widget event handlers are 
# overloaded to provide program specific event handling.
#------------------------------------------------------------------------------


class DialogMixedMetaboliteOutput(mixed_metabolite_output.MyDialog):
    """
    This dialog is used to output metabolite results and mixtures of 
    metabolite results to a variety of formats as governed by the format 
    selector widget. 
    
    The format parameter to __init__() must be one of the constants in 
    constants.ThirdPartyExportTypes.
    
    In general - There must be at least one Experiment tab open in the 
    main application for this dialog to launch. If the only tab contains 
    a 'New' Experiment, it must be run at least once before this dialog 
    can be used. If more than one Experiment tab is open in the Notebook,
    then the currently active one is the one whose results are output. 
    For the lcmodel and jmruitext formats, FID basis functions are created
    at a specified number of points and spectral resolution. The default
    values for these parameters are taken from the spectral resolution set
    in the Visualize tab (passed into the dialog by the 'local' parameter)
    but can be changed by the user in the relevant widgets if necessary.
    
    Format specific details:
    
    "lcmodel" format outputs all metabolites for one set of Experiment
    loop index (loop1, loop2, loop3) values in the currently selected tab.
    The loop values selected in the Visualize tab are used. The user must 
    select a directory and filename for output. The filename is used to
    write a text description of how the LCModel RAW files are created.
    All RAW files also contain a copy of this description above the actual
    LCModel RAW header and data sections
    
    "gava" format outputs all metabolites for all loop indices in the
    Experiment in the currently selected tab. The user must select a 
    directory and filename for output. The filename is used for the gava
    output file. This file also contains, above the results section, a text 
    description of how the gava results (and mixtures) are created.
    
    "jmruitext" format outputs all metabolites for one set of Experiment
    loop index (loop1, loop2, loop3) values in the currently selected tab.
    The loop values selected in the Visualize tab are used. The user must 
    select a directory and filename for output. The filename is used to
    write a text description of how the jMRUI Data Text files are created.
    
    "midasxml" format outputs all metabolites for all loop indices in the
    Experiment in the currently selected tab. The user must select a 
    directory and filename for output. The filename is used for the MIDAS XML
    output file name. This file contains two nodes, 
      1) VESPA_SIMULATION_MIDAS_EXPORT - has the description of how the 
         metabolites and metabolite mixtures were output.
      2) FITT_Generic_XML - contains the Experiment results.
    In both nodes, there are multiple "comment" or "param" tags, respectively
    which contain "name" and "value" attributes in which data is stored.
    There is no data stored in the actual tag, just attributes. This type of
    file is typically read into the MIDAS program to provide prior metabolite
    information for the FITT2 application.

    "nifti-mrs" format outputs all metabolites for one set of Experiment
    loop index (loop1, loop2, loop3) values in the currently selected tab.
    The loop values selected in the Visualize tab are used. The user must
    select a directory and filename for output. The filename is used to
    write an *.nii file.
    
    """
    def __init__(self, parent, experiment, local=None, format=None):
        if not parent:
            parent = wx.GetApp().GetTopWindow()

        mixed_metabolite_output.MyDialog.__init__(self, parent)

        #------------------------------------------------------------
        # set up a local container for some parameter settings that are
        # frequently referenced between processing objects for convenience
        #------------------------------------------------------------

        class FakeDataset(object):

            def __init__(self):

                self.spectral_dims = [2048,1,1,1]
                self.raw_dims      = [2048,1,1,1]
                self.sw            = 2500.0
                self.hpp           = self.sw / self.spectral_dims[0]
                self.resppm        = 4.7
                self.frequency     = 124.0
                self.spectral_hpp  = self.sw / self.spectral_dims[0]
                self.raw_hpp       = self.sw / self.raw_dims[0]


            def ppm2pts(self, val, acq=False, rel=False):
                dim0 = self.raw_dims[0] if acq else self.spectral_dims[0]
                hpp = self.raw_hpp if acq else self.spectral_hpp
                pts = self.frequency*val/hpp if rel else (dim0/2) - (self.frequency*(val-self.resppm)/hpp)
                pts = np.where(pts > 0, pts, 0)
                return pts

            def ppm2hz(self, val, acq=False, rel=False):
                hpp = self.raw_hpp if acq else self.spectral_hpp
                ppm = self.pts2hz(self.ppm2pts(val)) if rel else self.ppm2pts(val, rel=rel) * hpp
                return ppm

            def pts2ppm(self, val, acq=False, rel=False):
                dim0 = self.raw_dims[0] if acq else self.spectral_dims[0]
                hpp = self.raw_hpp if acq else self.spectral_hpp
                ppm = val*hpp/self.frequency if rel else (((dim0/2)-val)*(hpp/self.frequency))+self.resppm
                return ppm

            def pts2hz(self, val, acq=False, rel=False):
                hpp = self.raw_hpp if acq else self.spectral_hpp
                hz = val * hpp if rel else (self.ppm2pts(0.0) - val) * hpp
                return hz

            def hz2ppm(self, val, acq=False, rel=False):
                hpp = self.raw_hpp if acq else self.spectral_hpp
                val = self.pts2ppm(self.hz2pts(val)) if rel else self.pts2ppm(val / hpp)
                return val

            def hz2pts(self, val, acq=False, rel=False):
                hpp = self.raw_hpp if acq else self.spectral_hpp
                pts = val / hpp if rel else self.ppm2pts(0.0) - (val / hpp)
                return pts        
        
        self.local = FakeDataset()

        if not local:
            self.local.spectral_dims = [2048,1,1,1]
            self.local.raw_dims      = [2048,1,1,1]
            self.local.sw            = 2500.0
            self.local.hpp           = self.local.sw / self.local.spectral_dims[0]
            self.local.spectral_hpp  = local.sw / local.spectral_dims[0]
            self.local.raw_hpp       = local.sw / local.spectral_dims[0]
            self.local.resppm        = 4.7
            self.local.frequency     = 124.0
        else:
            self.local.spectral_dims = local.spectral_dims
            self.local.raw_dims      = local.raw_dims
            self.local.sw            = local.sw
            self.local.hpp           = local.sw / local.spectral_dims[0]
            self.local.spectral_hpp  = local.sw / local.spectral_dims[0]
            self.local.raw_hpp       = local.sw / local.spectral_dims[0]
            self.local.resppm        = local.resppm
            self.local.frequency     = local.frequency
        
        self.parent       = parent
        self.experiment   = experiment
        self.format       = format if format else _DEFAULT_OUTPUT_FORMAT
        
        self.local.apodization_value  = common_constants.DEFAULT_LINEWIDTH
        self.local.apodization_shape  = 'gaussian'
        
        self.final_prior = None
        
        #------------------------------
        # Initialize widget controls
        
        self._initialize_controls()

        self.Layout()
        self.Fit()
        
        self._improve_height()
        
        # Under Linux, the focus is elsewhere (?) unless I manually
        # set it to the list
        self.ListLoop1.SetFocus()
        
        self.Bind(wx.EVT_SIZE,  self.on_size)
        


    ##### Event Handlers ######################################################

    def on_list_select(self, event):
        # This is called when the user makes a selection in any of the lists.
        # Figure out which listctrl was selected
        for i in range(1, 4):
            listctrl = getattr(self, "ListLoop%d" % i)
            if event.GetId() == listctrl.GetId():
                break
                
        # Update the heading to reflect what was selected
        self._set_list_heading(listctrl, i - 1)
    
    
    def on_size(self, event):
        # Correct label wrapping if necessary.
        self._wrap_instructions()


    def on_browse(self, event): 
        default_path = util_config.get_last_export_path()
        
        if self.format in (constants.ThirdPartyExportTypes.LCMODEL,
                           constants.ThirdPartyExportTypes.JMRUI,
                          ):
            # These formats write a bunch of files and so we prompt users
            # to select a directory rather than a single filename.
            if self.format == constants.ThirdPartyExportTypes.LCMODEL:
                filename = "lcmodel_output_summary.txt"
                message = "LCModel Output Path"

            if self.format == constants.ThirdPartyExportTypes.JMRUI:
                filename = "jmrui-text_output_summary.txt"
                message  = "jMRUI Data Output Path"

            path = common_dialogs.pickdir(message=message,
                                          default_path=default_path)
            if path:
                self.LabelFilename.SetLabel(path)
                
        elif self.format in (constants.ThirdPartyExportTypes.ANALYSIS_DIRECT,):
            pass
                
        else:
            # These formats write a single file and so we prompt users
            # to select single filename.
            if self.format == constants.ThirdPartyExportTypes.GAVA:
                default_filename = "gava_output.txt"
                filter_ = "GAVA Mixed Output Filename (*.txt)|*.txt"
            elif self.format == constants.ThirdPartyExportTypes.MIDAS_PRIOR:
                default_filename = "midas_output.xml"
                filter_ = "MIDAS Mixed Output Filename (*.xml)|*.xml"
            elif self.format == constants.ThirdPartyExportTypes.ANALYSIS_PRIOR:
                default_filename = "analysis_prior_output.xml"
                filter_ = "Analysis Prior Mixed Output Filename (*.xml)|*.xml"
            elif self.format == constants.ThirdPartyExportTypes.NIFTI_MRS:
                default_filename = "nifti_mrs_output_3T_"
                filter_ = "NIfTI-MRS Mixed Output Filename (*.*)|*.*"

            filename = common_dialogs.save_as(filetype_filter=filter_,
                                              default_path=default_path,
                                              default_filename=default_filename)

            if filename:
                self.LabelFilename.SetLabel(filename)
                path, _ = os.path.split(filename)
            else:
                path = ""
                
            util_config.set_last_export_path(path)


    def on_sweep_width(self, event): 
        val = event.GetEventObject().GetValue()
        self.FloatLcmSweepWidth.SetValue(val)
        self.FloatMetrepSweepWidth.SetValue(val)
        self.FloatJmruiSweepWidth.SetValue(val)

        sw       = self.FloatLcmSweepWidth.GetValue()
        npts     = self.SpinLcmDataPoints.GetValue()
        self.dynamic_output_list.update_ppm_range(npts, sw)
        
    def on_data_points(self, event): 
        val = event.GetEventObject().GetValue()
        self.SpinLcmDataPoints.SetValue(val)
        self.SpinMetrepDataPoints.SetValue(val)
        self.SpinJmruiDataPoints.SetValue(val)

        sw       = self.FloatLcmSweepWidth.GetValue()
        npts     = self.SpinLcmDataPoints.GetValue()
        self.dynamic_output_list.update_ppm_range(npts, sw)

    def on_apodize(self, event): 
        val = event.GetEventObject().GetValue()
        self.FloatLcmApodize.SetValue(val)
        self.FloatMetrepApodize.SetValue(val)
        self.FloatJmruiApodize.SetValue(val)

    def on_lineshape(self, event): 
        index = event.GetEventObject().GetCurrentSelection()
        self.ChoiceLcmLineshape.SetSelection(index)
        self.ChoiceMetrepLineshape.SetSelection(index)        
        self.ChoiceJmruiLineshape.SetSelection(index)

    def on_select_all(self, event): 
        self.dynamic_output_list.select_all()

    def on_deselect_all(self, event): 
        self.dynamic_output_list.deselect_all()

    def on_add_metabolite(self, event):
        self.dynamic_output_list.add_row()
        self.Layout()
        self.Fit()        
        wx.CallAfter(self._improve_height)

    def on_remove_selected(self, event): 
        self.dynamic_output_list.remove_checked_rows()
        self.Layout()
        self.Refresh()
        
    def on_add_mixture(self, event):
        names = self.dynamic_output_list.names
        abbr  = self.dynamic_output_list.get_abbr()
        dialog = dialog_mixed_metabolite_designer.DialogMixedMetaboliteDesigner(self, names, abbr)
        if dialog.ShowModal() == wx.ID_OK:
            unique_name = dialog.unique_name
            mixture     = dialog.values
            if mixture:
                self.dynamic_output_list.add_row(unique_name, mixture)
                self.Layout()
                self.Fit()        
                # When the user chooses a new format, the dialog's content 
                # changes and we might have to readjust the height. On Gnome 
                # (but not OS X or Windows) we have to allow wx to process 
                # messages before calling self._improve_height(). If we just 
                # call it directly here, it won't calculate the correct 
                # height.
                wx.CallAfter(self._improve_height)


    def on_ok(self,event):
        # Validate controls
        msg = self._is_gui_valid()

        if msg:
            common_dialogs.message(msg, None, common_dialogs.I_OK)
        else:
            # All is well, do the format specific output
            wx.BeginBusyCursor()

            cmt = ["Vespa-Simulation Mixed Metabolite Output"]
            cmt.append(_VESPA_FYI_COMMENT)
            cmt.append("")
            cmt.append("Output Path/Filename = " + self.LabelFilename.GetLabel().strip())
            cmt.append("Output Loop Values = " + self._build_loops_string())
            cmt.append("Output Comment")
            cmt.append("-" * 75)
            cmt += (self.TextComment.GetValue()).split('\n')
            cmt.append("")
            cmt.append("Experiment Information")
            cmt.append("-" * 75)
            cmt += (str(self.experiment)).split('\n')
            cmt.append("")
            cmt.append("Metabolite Formatting Information")
            cmt.append("-" * 75)

            lines = self.dynamic_output_list.get_values()
            for line in lines:
                s = "Name=%(metabolite)s Abbr=%(abbr)s Scale=%(scale)s "    \
                    "Shift=%(shift)s PPM Start=%(range_start)s "            \
                    "PPM End=%(range_end)s" % line
                cmt.append(s)
                
                if line["mixture"]:
                    mix_cmt = "  Mixture of [metab*scale] = "
                    for i, mix_line in enumerate(line["mixture"]):
                        if i:
                            mix_cmt += " + "
                        mix_cmt += "%s*%f" % (mix_line[0], mix_line[1])
                    cmt.append(mix_cmt)
            
            # Map the format to the appropriate function.
            ExportTypes = constants.ThirdPartyExportTypes
            function_map = {
                ExportTypes.LCMODEL         : self._do_output_lcmodel,
                ExportTypes.ANALYSIS_PRIOR  : self._do_output_analysis_prior,
                ExportTypes.MIDAS_PRIOR     : self._do_output_midasxml,
                ExportTypes.JMRUI           : self._do_output_jmruitext,
                ExportTypes.GAVA            : self._do_output_gava,
                ExportTypes.ANALYSIS_DIRECT : self._do_output_analysis_direct,
                ExportTypes.NIFTI_MRS       : self._do_output_nifti_mrs,
                           }
                           
            function = function_map[self.format]
                
            wx.EndBusyCursor()
            
            try:
                function(cmt, lines)
            except IOError as xxx_todo_changeme:
                (error_number, error_string) = xxx_todo_changeme.args
                msg = """Exporting to "%s" failed. The operating system message is below --\n\n""" % filename
                msg += error_string
            else:
                # FIXME - decide if we should allow user to return to dialog to
                #        output same data in another format without losing 
                #        the work they did setting up the mixtures.
                
                # we were successful, close dialog
                self.Close()


            if msg:
                common_dialogs.message(msg, None, common_dialogs.I_OK)




    ##### Internal helper functions  ##########################################

    def _build_loops_string(self):
        """
        When this dialog is called, some of the output formats need to know 
        what one set of metabolite results to output if the Experiment has
        more than one settings in either loop1, loop2 or loop3. A dictionary
        called 'loops' is passed in that contains the index of loop1/2/3 
        that is currently selected in the Visualize tab. Also send in are
        the label for loop1/2/3 and actual loop 'value' for the given index.
        """

        if self.ListLoop1.IsShown() and self.panel_grid_loop.IsShown():
            label1 = self.LabelLoop1.GetLabel().strip()
            index1 = wx_util.get_selected_item_indices(self.ListLoop1)[0]
        else:
            label1 = 'Loop1 Inactive'
            index1 = 0
        
        if self.ListLoop2.IsShown() and self.panel_grid_loop.IsShown():
            label2 = self.LabelLoop2.GetLabel().strip()
            index2 = wx_util.get_selected_item_indices(self.ListLoop2)[0]
        else:
            label2 = 'Loop2 Inactive'
            index2 = 0

        if self.ListLoop3.IsShown() and self.panel_grid_loop.IsShown():
            label3 = self.LabelLoop3.GetLabel().strip()
            index3 = wx_util.get_selected_item_indices(self.ListLoop3)[0]
        else:
            label3 = 'Loop3 Inactive'
            index3 = 0

        loops_string_label = '( '+label1+', '+label2+', '+label3+' )'
        loops_string_index = '('+str(index1+1)+','+str(index2+1)+','+str(index3+1)+')'
        
        return loops_string_index+'  '+loops_string_label
    

    def _improve_height(self):
        # No matter what format the user chooses, we use a scrolled window to
        # contain the list of metabs because with a fixed-sized (non-scrolled)
        # panel, experiments that contain a lot of metabs (20+) can cause 
        # this dialog to exceed the display height. However, the scrolled 
        # window has its own problem: it doesn't size itself intelligently.
        # It always has the same (small) default height.
        #
        # So here we check to see if the scrolled window is actually scrolled;
        # i.e. it contains content that it can't completely display in its
        # current area. If so, we increase the dialog's height exactly 
        # enough to allow the scrolled window to expand so that the user 
        # doesn't have to scroll to see the contents.
        _, display_height = wx.GetDisplaySize()
        dialog_width, dialog_height = self.GetSize()
        
        # Compare virtual height with real height.
        # delta is how much bigger it needs to be to display all of its 
        # content without scrolling.
        _, v_height = self.ScrolledWindowDynamicList.GetVirtualSize()
        _, r_height = self.ScrolledWindowDynamicList.GetClientSize()        
        delta = v_height - r_height
        
        # max_delta is the max we can increase the dialog height before it
        # exceeds the display area. Note that wx reports the raw display 
        # area without accounting for things like the Windows taskbar or the
        # OS X dock. Actual space available for use by applications may be
        # less. To account for this we subtract a fudge factor of 132 pixels.
        # This is pretty arbitrary, although on my Mac laptop the OS X dock 
        # and the top menu occupy 132 pixels and the dock is huge relative
        # to the Windows taskbar and Gnome's similar thingies, so 
        # hopefully this will be sufficient everywhere. 
        max_delta = (display_height - dialog_height) - 132
        
        delta = min(delta, max_delta)
        
        if delta > 0:
            self.SetSize( (dialog_width, dialog_height + delta) )

        self.Center()
        
        
    def _initialize_controls(self):
        # We set this to a default value and change it if we need to.
        self.LabelInstructions.SetLabel("There are no loops for this experiment.")

        #----------------------------------------------------------------------
        # set up Experiment Loop list controls

        # Make a shorthand reference for the labels above the lists
        self.heading_labels = [getattr(self, "LabelLoop%d" % i) for i 
                                                                in range(1, 4)]        

        # # Fiddle with the grid sizer. We tell it that it should have flexible
        # rows (i.e. they can be of different height) but that the columns
        # should be inflexible (i.e. they shrink/grow, but they're always
        # equal to one another).
        # When there's just one or two loops, this arrangement looks better
        # than allowing the lists to grow all the way across the dialog.
        grid_sizer = self.ListLoop1.GetContainingSizer()
        grid_sizer.SetFlexibleDirection(wx.VERTICAL)
        grid_sizer.SetNonFlexibleGrowMode(wx.FLEX_GROWMODE_ALL)

        # All we need from the pulse seq is loop labels.
        loop_labels = self.experiment.pulse_sequence.loop_labels

        for i, dim in enumerate(self.experiment.dims):
            listctrl = getattr(self, "ListLoop%d" % (i + 1))
            label    = getattr(self, "LabelLoop%d" % (i + 1))

            if dim == mrs_experiment.DEFAULT_LOOP:
                # This is an empty loop.
                listctrl.Hide()
                label.Hide()
            else:
                self.LabelInstructions.SetLabel("Select the experiment dimension (loop indices) you want to use.")
                
                # Build the ListCtrl columns, set label & font
                listctrl.ClearAll()
                listctrl.InsertColumn(0, "Index", wx.LIST_FORMAT_RIGHT)
                listctrl.InsertColumn(1, loop_labels[i])
                label.SetLabel("Loop %d" % (i + 1))
                
                self._set_list_heading(listctrl, i)

                # We use monospace font so that the padding we use (spaces)
                # and the numbers will line up correctly.
                wx_util.set_font_to_monospace(listctrl)

                # Figure out the width (in digits) of the max index value and
                # the max dim. This allows us to right justify the numbers
                # in the lists which makes them much easier to read.
                index_digits = len(str(len(dim)))
                value_digits = len("%d" % max(dim))

                is_int = all([int(value) == value for value in dim])

                if is_int:
                    # All dim values are ints
                    formatter = "%d"
                else:
                    # Some values are floats. Format them as such and account
                    # for the width of the digits to the right of the decimal.
                    formatter = "%." + str(_SIGNIFICANT_DIGITS) + "f"
                    value_digits += _SIGNIFICANT_DIGITS

                # Add some padding
                formatter = "   " + formatter

                # Populate the list
                for j, value in enumerate(dim):
                    listctrl.InsertItem(j, str(j + 1).rjust(index_digits))

                    listctrl.SetItem(j, 1, (formatter % value).rjust(value_digits))

                # Size the columns optimally
                listctrl.SetColumnWidth(0, _find_best_column_size(listctrl, 0))
                listctrl.SetColumnWidth(1, _find_best_column_size(listctrl, 1))
                
        #----------------------------------------------------------------------
        # sets up other widgets in mixed output dialog from values in the 
        # experiment sent into the object initialization
        
        self.LabelStatus.SetLabel("")
        self.LabelFilename.SetLabel("")
        
        # The grid sizer for the metabs/mixed metabs list is marked with
        # a placeholder so that I can find it now (at runtime).
        placeholder = self.LabelMetaboliteListGridSizerPlaceholder
        self.MetaboliteGridSizer = placeholder.GetContainingSizer()
        parent = placeholder.GetParent()
        placeholder.Destroy()
        
        # Add headings to the first row of the grid sizer.
        self.MetaboliteGridSizer.Clear()
        self.MetaboliteGridSizer.SetRows(1)
        headings = (None, "Metabolite\nList", "Unique\nAbbreviation", "Scale", 
                    "Frequency\nShift [ppm]",  "Range Start\n[ppm]", "Range End\n[ppm]")
        
        for heading in headings:
            if heading:
                label = wx.StaticText(parent, label=heading, style=wx.ALIGN_CENTRE)
                self.MetaboliteGridSizer.Add(label, 0, wx.EXPAND|wx.ALIGN_CENTER_VERTICAL)
            else:
                self.MetaboliteGridSizer.AddSpacer( 1 )
                
        # Columns 1 & 2 (the metab combobox and the metab abbreviation) 
        # expand to fill whatever space is available.
        self.MetaboliteGridSizer.AddGrowableCol(1, 1)
        self.MetaboliteGridSizer.AddGrowableCol(2, 1)

        # Add widgets to dialog that wxGlade could not 
        self.dynamic_output_list = DynamicOutputList(self.ScrolledWindowDynamicList,
                                                     self.MetaboliteGridSizer,
                                                     self.experiment.metabolites,
                                                     self.local)

        # We add the OK & Cancel buttons dynamically so that they're in the 
        # right order under OS X, GTK, Windows, etc.
        self.ButtonOk, self.ButtonCancel = \
                    wx_util.add_ok_cancel(self, self.LabelOkCancelPlaceholder,
                                          self.on_ok)

        # set initial values in some of the widgets
        if self.local.apodization_shape == 'gaussian':
            shape = 0
        else:
            shape = 1
            
        # All panels are hidden by default, and then we show the ones
        # appropriate for the selected format.
        for panel in (self.panel_grid_loop, self.panel_output_location, 
                      self.panel_format_specific_parameters, 
                      self.panel_parameters_lcmodel, 
                      self.panel_parameters_metabolitereport,
                      self.panel_parameters_jmruitext,
                     ):
            panel.Hide()
            
        if self.format == constants.ThirdPartyExportTypes.LCMODEL:
            self.SetTitle("Third Party Export to LCModel")
            self.panel_grid_loop.Show()
            self.panel_output_location.Show()
            self.panel_format_specific_parameters.Show()
            self.panel_parameters_lcmodel.Show()
        elif self.format == constants.ThirdPartyExportTypes.GAVA:
            self.SetTitle("Third Party Export to GAVA Text")
            self.LabelInstructions.SetLabel("All loops will be saved for this format.")
            self.panel_output_location.Show()
        # FIXME PS - at present, this is the only code that references 
        # the MetaboliteReport format. It's not implemented otherwise.
        # elif self.format == constants.ThirdPartyExportTypes.METABOLITEREPORT:
        #     self.SetTitle("Third Party Export to MetaboliteReport")
        #     self.panel_grid_loop.Show()
        #     self.panel_output_location.Show()
        #     self.panel_format_specific_parameters.Show()
        #     self.panel_parameters_metabolitereport.Show()
        elif self.format == constants.ThirdPartyExportTypes.JMRUI:
            self.SetTitle("Third Party Export to jMRUI Text")
            self.panel_grid_loop.Show()
            self.panel_output_location.Show()
            self.panel_format_specific_parameters.Show()
            self.panel_parameters_jmruitext.Show()
        elif self.format == constants.ThirdPartyExportTypes.MIDAS_PRIOR:
            self.SetTitle("Third Party Export to MIDAS XML")
            self.panel_grid_loop.Show()
            self.panel_output_location.Show()
        elif self.format == constants.ThirdPartyExportTypes.ANALYSIS_PRIOR:
            self.SetTitle("Third Party Export to Analysis Prior XML")
            self.panel_grid_loop.Show()
            self.panel_output_location.Show()
        elif self.format == constants.ThirdPartyExportTypes.ANALYSIS_DIRECT:
            self.SetTitle("Analysis Prior Selection ")
            self.panel_grid_loop.Show()
#            self.panel_output_location.Hide()
        elif self.format == constants.ThirdPartyExportTypes.NIFTI_MRS:
            self.SetTitle("Third Party Export to NIfTI-MRS")
            self.panel_grid_loop.Show()
            self.panel_output_location.Show()
            self.panel_format_specific_parameters.Show()
            self.panel_parameters_jmruitext.Show()


        #-----------------------------
        self.TextLcmFmtdat.SetValue('(2E16.6)')
        self.FloatLcmTramp.SetValue(1.0)
        self.FloatLcmVolume.SetValue(1.0)
        self.FloatLcmSweepWidth.SetRange(constants.SWEEP_WIDTH_MIN,constants.SWEEP_WIDTH_MAX)
        self.FloatLcmSweepWidth.SetValue(self.local.sw)
        self.SpinLcmDataPoints.SetRange(constants.SPECTRAL_POINTS_MIN,constants.SPECTRAL_POINTS_MAX)
        self.SpinLcmDataPoints.SetValue(self.local.spectral_dims[0])
        self.FloatLcmApodize.SetRange(constants.LINEWIDTH_MIN,constants.LINEWIDTH_MAX)
        self.FloatLcmApodize.SetValue(self.local.apodization_value)
        self.ChoiceLcmLineshape.SetSelection(shape)
        #-----------------------------
        self.TextMetrepPulseq.SetValue('se')
        self.TextMetrepEcho.SetValue('030')
        self.FloatMetrepField.SetValue(3.0)
        self.SpinMetrepOffset.SetValue(10)
        self.FloatMetrepTime1.SetValue(0.0)
        self.FloatMetrepTime2.SetValue(0.0)
        self.FloatMetrepTime3.SetValue(0.0)
        self.FloatMetrepTimeMix.SetValue(0.0)
        self.FloatMetrepSweepWidth.SetRange(constants.SWEEP_WIDTH_MIN,constants.SWEEP_WIDTH_MAX)
        self.FloatMetrepSweepWidth.SetValue(self.local.sw)
        self.SpinMetrepDataPoints.SetRange(constants.SPECTRAL_POINTS_MIN,constants.SPECTRAL_POINTS_MAX)
        self.SpinMetrepDataPoints.SetValue(self.local.spectral_dims[0])
        self.FloatMetrepApodize.SetRange(constants.LINEWIDTH_MIN,constants.LINEWIDTH_MAX)
        self.FloatMetrepApodize.SetValue(self.local.apodization_value)
        self.ChoiceMetrepLineshape.SetSelection(shape)
        #-----------------------------
        self.FloatJmruiSweepWidth.SetRange(constants.SWEEP_WIDTH_MIN,constants.SWEEP_WIDTH_MAX)
        self.FloatJmruiSweepWidth.SetValue(self.local.sw)
        self.SpinJmruiDataPoints.SetRange(constants.SPECTRAL_POINTS_MIN,constants.SPECTRAL_POINTS_MAX)
        self.SpinJmruiDataPoints.SetValue(self.local.spectral_dims[0])
        self.FloatJmruiApodize.SetRange(constants.LINEWIDTH_MIN,constants.LINEWIDTH_MAX)
        self.FloatJmruiApodize.SetValue(self.local.apodization_value)
        self.ChoiceJmruiLineshape.SetSelection(shape)

        sw       = self.FloatLcmSweepWidth.GetValue()
        npts     = self.SpinLcmDataPoints.GetValue()
        self.dynamic_output_list.set_max_ppm_range(npts, sw)


       
    def _is_gui_valid(self, check_for_unique_name=False):
        """
        Examines the contents of the GUI and determines whether or not
        what the user has entered is valid. If this method finds something
        it doesn't like, it returns a message string indicating the problem
        that's appropriate for displaying in a message box. Otherwise it 
        returns None.
        """
        msg = None

        if self.panel_grid_loop.IsShown():
            # Ensure a dim is selected in each visible list.
            for i in range(1, 4):
                listctrl = getattr(self, "ListLoop%d" % i)
                if listctrl.IsShown():
                    selections = wx_util.get_selected_item_indices(listctrl)
                    if not selections:
                        msg = "Please select a value for loop %d." % i
                        break

        if not msg and self.format != constants.ThirdPartyExportTypes.ANALYSIS_DIRECT:
            # All outputs except ANALYSIS_DIRECT need a filename and path
            filename = self.LabelFilename.GetLabel()
            if not filename:
                msg = "Please use the Browse button to select an output destination."
            else:
                path, _  = os.path.split(filename)
                if not os.path.exists(path) or not os.path.isdir(path):
                    msg = """The path "%s" doesn't exist or is not a directory.""" % path

        if not msg:
            # not checking for parameters in spin controls or 
            # float spin controls. We assume they should have 
            # values and be ints or floats
            
            # check to ensure there are values in text controls
            if self.format == constants.ThirdPartyExportTypes.LCMODEL:
                if not self.TextLcmFmtdat.GetValue().strip():
                    msg = "Please enter a value for FMTDAT."

            # FIXME PS - METABOLITEREPORT isn't implemented. Please implement
            # or remove.
            # elif self.format == constants.ThirdPartyExportTypes.METABOLITEREPORT:
            #     val = self.TextMetrepPulseq.GetValue().strip()
            #     if val == '':
            #         msg = "Please enter a value for Pulseq String."
            #     val = self.TextMetrepEcho.GetValue().strip()
            #     if val == '':
            #         msg = "Please enter a value for Echo String."

        if not msg:

            lines = self.dynamic_output_list.get_values()
            
            abbrs = []
            for line in lines:
                abbr = line["abbr"]
                
                if not abbr:
                    msg = "Please enter an abbreviation for all metabolites in the list."
                    
                if not msg:
                    # be sure that no inappropriate characters are in abbreviations
                    match = [c in _OUTPUT_ABBREVIATION_DISALLOWED for c in abbr]
                    if any(match):
                        msg = _INVALID_ABBREVIATION_MESSAGE % abbr

                if msg:
                    # No point in going through the other abbreviations.
                    break
                else:
                    abbrs.append(abbr)

            # make sure there are no duplicate output names, these are used
            # as output file names or unique identifiers in the formats 
            if not msg:
                if len(set(abbrs)) != len(abbrs):
                    msg = "There is at least one duplicate metabolite abbreviation in the output list."

        return msg


    def _set_list_heading(self, listctrl, i):
        # Figure out which item (if any) is selected and update the heading
        # to contain that info. We do this because the background color for
        # a selected item is very hard to see on Windows 7, so it's hard for
        # users to see what they've selected. This is only a problem under
        # Win7. It's fine under Win XP, OS X, and Linux/GTK.
        selections = wx_util.get_selected_item_indices(listctrl)
        label = "Loop %d" % (i + 1)
        if selections:
            label += ( " = %s" % listctrl.GetItem(selections[0], 1).GetText().strip())
        
        self.heading_labels[i].SetLabel(label)
        
        # This recenters the text
        self.heading_labels[i].GetContainingSizer().Layout()
        

    def _wrap_instructions(self):
        wx_util.wrap_label(self.LabelInstructions, self)


    #####     Methods for different output formats    ####################

    def _do_output_lcmodel(self, all_lines, output_list):

        # In LCMode headers all lines start with a space " "
        all_lines = [' '+line for line in all_lines]
        
        # Create a dictionary of all metabolites that exist
        # for this step (ie. loop1, loop2, loop3) of the Experiment

        nmet   = len(self.experiment.metabolites)
        nstep1 = self.ListLoop1.GetItemCount()
        nstep2 = self.ListLoop2.GetItemCount()
        nstep3 = self.ListLoop3.GetItemCount()
        
        if nstep1 == 0:
            nstep1 = 1
            index1 = 0
        else: 
            index1 = wx_util.get_selected_item_indices(self.ListLoop1)[0] 
            
        if nstep2 == 0:
            nstep2 = 1
            index2 = 0
        else: 
            index2 = wx_util.get_selected_item_indices(self.ListLoop2)[0]
        
        if nstep3 == 0:
            nstep3 = 1
            index3 = 0
        else: 
            index3 = wx_util.get_selected_item_indices(self.ListLoop3)[0]

        offset = index1 + index2*nstep1 + index3*nstep1*nstep2
        sims   = self.experiment.simulations[(nmet*offset):(nmet*(offset+1))]
        
        metabs_dict = {}
        for sim in sims:
            metabs_dict[sim.metabolite.name] = sim.deflate(flavor=Deflate.DICTIONARY)
            
        # Retrieve header specific information from GUI and spectral
        # parameters for calculating the FIDS
        
        sw       = self.FloatLcmSweepWidth.GetValue()
        npts     = self.SpinLcmDataPoints.GetValue()
        apod     = self.FloatLcmApodize.GetValue()
        b0       = self.experiment.b0

        fmtdat   = self.TextLcmFmtdat.GetValue()
        tramp    = str(self.FloatLcmTramp.GetValue())
        volume   = str(self.FloatLcmVolume.GetValue())
        broad    = self.ChoiceLcmLineshape.GetStringSelection()
        sw_str   = str(sw)
        vsize    = str(npts)
        apod_str = str(apod)
        b0_str   = str(b0)
        
        if self.experiment.isotope == "1H":
            # should be 4.7
            resppm = common_constants.DEFAULT_PROTON_CENTER_PPM   
        else:
            # should be 0.0
            resppm = common_constants.DEFAULT_XNUCLEI_CENTER_PPM   

        singlet_flag = self.CheckLcmSinglet.IsChecked()
        
        # retrieve path from label
        path = self.LabelFilename.GetLabel()
        filename = os.path.join(path, "lcmodel_output_summary.txt")
        
        # create the LCModel common header
        
        lcbase =     [" "]
        lcbase.append(" "+"=" * 75)
        lcbase.append(" This LCModel format RAW file was created using the ")
        lcbase.append(" Vespa-Simulation spectral simulation program using ")
        lcbase.append(" the following settings and parameters ")
        lcbase.append(" ")
        lcbase.append(" Sweep Width = "+sw_str  +" Hz ")
        lcbase.append(" Vector Size = "+vsize   +" points ")
        lcbase.append(" Apodization = "+apod_str+" Hz "+broad+" broadening")
        lcbase.append(" B0 Field    = "+b0_str  +" MHz ")
        lcbase.append(" Ref Singlet = "+str(singlet_flag))
        lcbase.append("  ")

        # save the Mixed Output and LCModel common headers out into
        # an informative text file in the directory that will contain
        # the LCModel RAW files.
        _write_lines(filename, all_lines + lcbase, True)
        
        # parse all of the metabolites in the dynamic metabolite list
        # into time and frequency FID data with LCModel headers
        for vals in output_list:

            abbr = vals["abbr"]

            lctime =     [" $NMID ID='"+abbr+"'"]
            lctime.append(" FMTDAT='"+fmtdat+"'")
            lctime.append(" VOLUME="+volume)
            lctime.append(" TRAMP="+tramp)
            lctime.append(" $END")

            header_time   = all_lines + lcbase + lctime

            time = _make_basis(vals, metabs_dict, npts, sw, apod, 
                               broad, b0, resppm, singlet_flag)
            
            time = time * (((np.arange(npts)+1)%2)*2-1)   # chop data

            header_time += [" %15.6E %15.6E" % (z.real, z.imag) for z in time]

            header_time.append(" ")

            _write_lines(os.path.join(path, abbr + '.RAW'), header_time, True)


            lcfreq =     [" This data has been FFTd to be in the FREQUENCY domain"]
            lcfreq.append(" ")
            lcfreq.append(" $NMID ID='"+abbr+"'")
            lcfreq.append(" FMTDAT='"+fmtdat+"'")
            lcfreq.append(" VOLUME="+volume)
            lcfreq.append(" TRAMP="+tramp)
            lcfreq.append(" $END")

            header_freq   = all_lines + lcbase + lcfreq

            freq = np.fft.fft(time[:])

            header_freq += [" %15.6E %15.6E" % (z.real, z.imag) for z in freq]

            header_freq.append(" ")

            _write_lines(os.path.join(path, abbr + '_freq.RAW'), header_freq, 
                        True)



    def _do_output_gava(self, all_lines, output_list):

        # Add the Results section header
        all_lines.append("")
        all_lines.append("Simulation Spectral Results") 
        all_lines.append("-" * 75)

        # In GAVA, comment lines start with ';'
        # Set all lines in the 'header' to be comment lines
        all_lines = [';'+line for line in all_lines]

        filename = self.LabelFilename.GetLabel()
        
        lines  = []

        nmet   = len(self.experiment.metabolites)
        nstep1 = self.ListLoop1.GetItemCount()
        nstep2 = self.ListLoop2.GetItemCount()
        nstep3 = self.ListLoop3.GetItemCount()
        
        if nstep1 == 0:
            nstep1 = 1
            
        if nstep2 == 0:
            nstep2 = 1
        
        if nstep3 == 0:
            nstep3 = 1

        nsteps = nstep1 * nstep2 * nstep3
        
        for i in range(nsteps):
            
            sims = self.experiment.simulations[(nmet*i):(nmet*(i+1))]
            
            # Create a dictionary of all metabolites that exist
            # for this step (ie. loop1, loop2, loop3) of the Experiment
            
            metabs_dict = {}
            for sim in sims:
                mdict = sim.deflate(flavor=Deflate.DICTIONARY)
                dims  = [sim.metabolite.name,sim.dims[0],sim.dims[1],sim.dims[2]]
                metabs_dict[sim.metabolite.name] = [mdict,dims]
                
            # Use the dictionary of metabolite values to create text 
            # output for only the metabolites and mixtures listed in 
            # the dynamic list widget
            for vals in output_list:
                ppms   = np.array([],dtype='float')
                areas  = np.array([],dtype='float')
                phases = np.array([],dtype='float')
        
                mname  = vals["metabolite"]
                abbr   = vals["abbr"]
                scale  = vals["scale"]
                shift  = vals["shift"]
                ppmstr = vals["range_start"]
                ppmend = vals["range_end"]

                # formula is a tuple of metabolite name and scale
                # factors, or it is None if not a mixture
                formula = vals["mixture"]
                
                if not formula:             
                    # single metabolite - apply global shift and scale
                    #    values to the ppms and areas respectively
                    tmp  = metabs_dict[mname][0]
                    dims = metabs_dict[mname][1]
                    ppms   = tmp['ppms'] + shift
                    areas  = tmp['areas'] * scale
                    phases = tmp['phases']

                else:   
                    # metabolite mixture - apply global shift and scale
                    #    values as well as mixture scale value
                    for mix in formula:
                        tmp  = metabs_dict[mix[0]][0]
                        dims = metabs_dict[mix[0]][1]
                        ppms   = np.concatenate((ppms,  (tmp['ppms'] + shift)))
                        areas  = np.concatenate((areas, (tmp['areas'] * scale * mix[1])))
                        phases = np.concatenate((phases, tmp['phases']))
        
                # sort for ppmstr and ppmend values
                indx = ((ppms > ppmstr) & (ppms < ppmend)).nonzero()[0]
                if indx.size:
                    ppms   = ppms[indx]
                    areas  = areas[indx]
                    phases = phases[indx]
                    
                    for i in range(len(ppms)):
                        line = abbr           + '\t' + str(dims[1]) + '\t' + \
                               str(dims[2])   + '\t' + str(dims[3]) + '\t'
                        line += str(i)        + '\t' + str(ppms[i]) + '\t' + \
                                str(areas[i]) + '\t' + str(phases[i])
                        lines.append(line)
        
        all_lines += lines

        _write_lines(filename, all_lines)



    def _do_output_jmruitext(self, all_lines, output_list):

        # Create a dictionary of all metabolites that exist
        # for this step (ie. loop1, loop2, loop3) of the Experiment

        nmet   = len(self.experiment.metabolites)
        nstep1 = self.ListLoop1.GetItemCount()
        nstep2 = self.ListLoop2.GetItemCount()
        nstep3 = self.ListLoop3.GetItemCount()
        
        if nstep1 == 0:
            nstep1 = 1
            index1 = 0
        else: 
            index1 = wx_util.get_selected_item_indices(self.ListLoop1)[0] 
            
        if nstep2 == 0:
            nstep2 = 1
            index2 = 0
        else: 
            index2 = wx_util.get_selected_item_indices(self.ListLoop2)[0]
        
        if nstep3 == 0:
            nstep3 = 1
            index3 = 0
        else: 
            index3 = wx_util.get_selected_item_indices(self.ListLoop3)[0]

        offset = index1 + index2*nstep1 + index3*nstep1*nstep2
        sims   = self.experiment.simulations[(nmet*offset):(nmet*(offset+1))]
        
        metabs_dict = {}
        for sim in sims:
            metabs_dict[sim.metabolite.name] = sim.deflate(flavor=Deflate.DICTIONARY)
            
        # Retrieve header specific information from GUI and spectral
        # parameters for calculating the FIDS
        
        sw       = self.FloatJmruiSweepWidth.GetValue()
        dwell    = 1000.0/float(sw)                     # in [ms]
        npts     = self.SpinJmruiDataPoints.GetValue()
        apod     = self.FloatJmruiApodize.GetValue()
        b0       = float(self.experiment.b0) * 1e6

        broad     = self.ChoiceJmruiLineshape.GetStringSelection()
        sw_str    = str(sw)
        dwell_str = "%6.5E" % dwell
        vsize     = str(npts)
        apod_str  = str(apod)
        b0_str    = "%6.5E" % b0
        
        if self.experiment.isotope == "1H":
            # should be 4.7
            resppm = common_constants.DEFAULT_PROTON_CENTER_PPM   
        else:
            # should be 0.0
            resppm = common_constants.DEFAULT_XNUCLEI_CENTER_PPM   

        # retrieve path from label
        path = self.LabelFilename.GetLabel()
        filename = os.path.join(path, "jmrui-text_output_summary.txt")
        
        # save the Mixed Output and jMRUI common headers out into
        # an informative text file in the directory that will contain
        # the jMRUI text files.
        _write_lines(filename, all_lines)

        # parse all of the metabolites in the dynanic metabolite list
        # into time and frequency FID data with LCModel headers

        for vals in output_list:

            abbr = vals["abbr"]
            filename_data = os.path.join(path, abbr+'.txt')
            
            jheader =     ["jMRUI Data Textfile"]
            jheader.append(" ")
            jheader.append("Filename: "+abbr+".txt")
            jheader.append(" ")
            jheader.append("PointsInDataset: "+vsize)
            jheader.append("DatasetsInFile: 1")
            jheader.append("SamplingInterval: "+dwell_str)
            jheader.append("ZeroOrderPhase: 0E0")
            jheader.append("BeginTime: 0E0")
            jheader.append("TransmitterFrequency: "+b0_str)
            jheader.append("MagneticField: 0E0")
            jheader.append("TypeOfNucleus: 0E0")
            jheader.append("NameOfPatient: ")
            jheader.append("DateOfExperiment: ")
            jheader.append("Spectrometer: Vespa-Simulation")
            jheader.append("AdditionalInfo: see 'readme' file for Vespa-Simulation output synopsis")
            jheader.append(" ")
            jheader.append("  ")
            jheader.append("Signal and FFT ")
            jheader.append("sig(real)\tsig(imag)\tfft(real)\tfft(imag)")
            jheader.append("Signal 1 out of 1 in file")

            time = _make_basis(vals, metabs_dict, npts, sw, apod, 
                               broad, b0/1e6, resppm, False)
            
            #time = np.conj(time[:])
            
            time = time * (((np.arange(npts)+1)%2)*2-1)   # chop data
            # to make data display correctly in jMRUI we need to apply
            # a complex conjugate to the FIDs 
            for i in range(len(time)):
                time[i] = time[i].real-1j*time[i].imag
            freq = np.fft.fft(time[:])

            for a_time, a_freq in zip(time, freq):
                params = (a_time.real, a_time.imag, a_freq.real, a_freq.imag)
                jheader.append("%6.5E\t%6.5E\t%6.5E\t%6.5E" % params)
                
            _write_lines(filename_data, jheader)
            
            
    def _do_output_midasxml(self, all_lines, output_list):
        stamp = util_time.now(util_time.ISO_TIMESTAMP_FORMAT).split('T')
        
        # MIDAS makes a somewhat odd use of XML in that all its data seems
        # to be saved into attributes of elements named 'param'
        #
        # Still, we agreed to support them so we will humour them.
        
        # first, let MIDAS know which node uses it (ie. FITT_Generic_XML)
        # second, drop our Vespa comment into its own little node
        
        root = ElementTree.Element("FITT_Generic_XML",
                                   { "Creation_date" : stamp[0],
                                     "Creation_time" : stamp[1]  })
        
        e = ElementTree.Element("VESPA_SIMULATION_MIDAS_EXPORT")
        for i,line in enumerate(all_lines):
            iline = "line%4.4i" % i
            util_xml.TextSubElement(e, "comment", "", 
                                    {'line':iline, 'value':line}) 
        root.append(e)                  

        # third, add all the Experiment lines in MIDAS style ...
        e = ElementTree.Element("PRIOR_METABOLITE_INFORMATION")
        
        # Create a dictionary of all metabolites that exist
        # for this step (ie. loop1, loop2, loop3) of the Experiment

        filename = self.LabelFilename.GetLabel()

        nmet   = len(self.experiment.metabolites)
        nstep1 = self.ListLoop1.GetItemCount()
        nstep2 = self.ListLoop2.GetItemCount()
        nstep3 = self.ListLoop3.GetItemCount()
        
        if nstep1 == 0:
            nstep1 = 1
            index1 = 0
        else: 
            index1 = wx_util.get_selected_item_indices(self.ListLoop1)[0] 
            
        if nstep2 == 0:
            nstep2 = 1
            index2 = 0
        else: 
            index2 = wx_util.get_selected_item_indices(self.ListLoop2)[0]
        
        if nstep3 == 0:
            nstep3 = 1
            index3 = 0
        else: 
            index3 = wx_util.get_selected_item_indices(self.ListLoop3)[0]

        offset = index1 + index2*nstep1 + index3*nstep1*nstep2
        sims   = self.experiment.simulations[(nmet*offset):(nmet*(offset+1))]
        
        lines  = []
        irun   = 1  # running index
        
        # Create a dictionary of all metabolites that exist
        # for this step (ie. loop1, loop2, loop3) of the Experiment
        
        metabs_dict = {}
        for sim in sims:
            mdict = sim.deflate(flavor=Deflate.DICTIONARY)
            dims  = [sim.metabolite.name] + sim.dims
            metabs_dict[sim.metabolite.name] = [mdict,dims]
            
        # Use the dictionary of metabolite values to create text 
        # output for only the metabolites and mixtures listed in 
        # the dynamic list widget
        for vals in output_list:
            ppms   = np.array([],dtype='float')
            areas  = np.array([],dtype='float')
            phases = np.array([],dtype='float')
    
            mname  = vals["metabolite"]
            abbr   = vals["abbr"]
            scale  = vals["scale"]
            shift  = vals["shift"]
            ppmstr = vals["range_start"]
            ppmend = vals["range_end"]

            # formula is a tuple of metabolite name and scale
            # factors, or it is None if not a mixture
            formula = vals["mixture"]
            
            if not formula:             
                # single metabolite - apply global shift and scale
                #    values to the ppms and areas respectively
                tmp  = metabs_dict[mname][0]
                dims = metabs_dict[mname][1]
                ppms   = tmp['ppms'] + shift
                areas  = tmp['areas'] * scale
                phases = tmp['phases']

            else:   
                # metabolite mixture - apply global shift and scale
                #    values as well as mixture scale value
                for mix in formula:
                    tmp  = metabs_dict[mix[0]][0]
                    dims = metabs_dict[mix[0]][1]
                    ppms   = np.concatenate((ppms,  (tmp['ppms'] + shift)))
                    areas  = np.concatenate((areas, (tmp['areas'] * scale * mix[1])))
                    phases = np.concatenate((phases, tmp['phases']))
    
            # sort for ppmstr and ppmend values
            indx = ((ppms > ppmstr) & (ppms < ppmend)).nonzero()[0]
            if indx.size:
                ppms   = ppms[indx]
                areas  = areas[indx]
                phases = phases[indx]
                
                for i in range(len(ppms)):
                    pname = "fitt_PriorLine%5.5i" % irun
                    
                    # Create a line of output. abbr is already a string, 
                    # but everything else needs to be stringified.
                    line = dims[1:] + [i, ppms[i], areas[i], phases[i]]
                    line = [abbr] + list(map(str, line))
                    line = "++".join(line)
                    
                    util_xml.TextSubElement(e, "param", "", 
                                            {'name':pname, 'value':line}) 
                    irun += 1
        
        root.append(e)
        # Prettify the XML and stuff root into a tree and write
        util_xml.indent(root) 
        tree = ElementTree.ElementTree(root)
        tree.write(filename, "utf-8")       



    def _do_output_analysis_direct(self, all_lines, output_list): 

        self._do_output_analysis_prior( all_lines, output_list, analysis_direct=True)


    def _do_output_analysis_prior(self, all_lines, output_list, analysis_direct=False):

        lines = "\n".join(all_lines)

        # Extract metabolites only for the specified Experiment loop indices

        nmet   = len(self.experiment.metabolites)
        nstep1 = self.ListLoop1.GetItemCount()
        nstep2 = self.ListLoop2.GetItemCount()
        nstep3 = self.ListLoop3.GetItemCount()
        
        if nstep1 == 0:
            nstep1 = 1
            index1 = 0
        else: 
            index1 = wx_util.get_selected_item_indices(self.ListLoop1)[0] 
            
        if nstep2 == 0:
            nstep2 = 1
            index2 = 0
        else: 
            index2 = wx_util.get_selected_item_indices(self.ListLoop2)[0]
        
        if nstep3 == 0:
            nstep3 = 1
            index3 = 0
        else: 
            index3 = wx_util.get_selected_item_indices(self.ListLoop3)[0]

        offset = index1 + index2*nstep1 + index3*nstep1*nstep2
        sims   = self.experiment.simulations[(nmet*offset):(nmet*(offset+1))]
        
        # Create a dictionary of all metabolites that exist
        # for this step (ie. loop1, loop2, loop3) of the Experiment
        
        metabs_dict = {}
        for sim in sims:
            mdict = sim.deflate(flavor=Deflate.DICTIONARY)
            dims  = [sim.metabolite.name] + sim.dims
            metabs_dict[sim.metabolite.name] = [mdict,dims]

        
        prior = mrs_prior.Prior()
        prior.source = 'experiment'
        prior.source_id = self.experiment.id
        prior.comment = lines
        prior.nucleus = self.experiment.isotope

        # Use the dictionary of metabolite values to create metabolite 
        # objects for only the metabolites and mixtures listed in the
        # dynamic list widget
        
        for vals in output_list:
            
            ppms   = np.array([],dtype='float')
            areas  = np.array([],dtype='float')
            phases = np.array([],dtype='float')
    
            mname  = vals["metabolite"]
            abbr   = vals["abbr"]
            scale  = vals["scale"]
            shift  = vals["shift"]
            ppmstr = vals["range_start"]
            ppmend = vals["range_end"]
            nspins = vals["nspins"]
            
            # formula is a tuple of metabolite name and scale
            # factors, or it is None if not a mixture
            formula = vals["mixture"]
            
            if not formula:             
                # single metabolite - apply global shift and scale
                #    values to the ppms and areas respectively
                tmp  = metabs_dict[mname][0]  
                dims = metabs_dict[mname][1]
                ppms   = tmp['ppms'] + shift
                areas  = tmp['areas'] * scale
                phases = tmp['phases']

            else:   
                # metabolite mixture - apply global shift and scale
                #    values as well as mixture scale value
                for mix in formula:
                    tmp  = metabs_dict[mix[0]][0]
                    dims = metabs_dict[mix[0]][1]
                    ppms   = np.concatenate((ppms,  (tmp['ppms'] + shift)))
                    areas  = np.concatenate((areas, (tmp['areas'] * scale * mix[1])))
                    phases = np.concatenate((phases, tmp['phases']))
            
            # sort for ppmstr and ppmend values
            indx = ((ppms > ppmstr) & (ppms < ppmend)).nonzero()[0]
            if indx.size:
                ppms   = ppms[indx]
                areas  = areas[indx]
                phases = phases[indx]            

            met = mrs_prior_metabolite.PriorMetabolite()

            met.spins  = nspins
            met.dims   = [abbr, index1, index2, index3]
            met.group  = ppms * 0
            met.ppms   = ppms
            met.areas  = areas
            met.phases = phases
            
            prior.metabolites[met.name] = met

        if analysis_direct:
            self.final_prior = prior
        else:
            filename = self.LabelFilename.GetLabel()
            util_export.export(filename, [prior])


    def _do_output_nifti_mrs(self, all_lines, output_list):

        lines = "\n".join(all_lines)

        # Create a dictionary of all metabolites that exist
        # for this step (ie. loop1, loop2, loop3) of the Experiment

        nmet = len(self.experiment.metabolites)
        nstep1 = self.ListLoop1.GetItemCount()
        nstep2 = self.ListLoop2.GetItemCount()
        nstep3 = self.ListLoop3.GetItemCount()

        if nstep1 == 0:
            nstep1 = 1
            index1 = 0
        else:
            index1 = wx_util.get_selected_item_indices(self.ListLoop1)[0]

        if nstep2 == 0:
            nstep2 = 1
            index2 = 0
        else:
            index2 = wx_util.get_selected_item_indices(self.ListLoop2)[0]

        if nstep3 == 0:
            nstep3 = 1
            index3 = 0
        else:
            index3 = wx_util.get_selected_item_indices(self.ListLoop3)[0]

        offset = index1 + index2 * nstep1 + index3 * nstep1 * nstep2
        sims = self.experiment.simulations[(nmet * offset):(nmet * (offset + 1))]

        metabs_dict = {}
        for sim in sims:
            metabs_dict[sim.metabolite.name] = sim.deflate(flavor=Deflate.DICTIONARY)

        # Retrieve header specific information from GUI and spectral
        # parameters for calculating the FIDS

        sw = self.FloatJmruiSweepWidth.GetValue()
        npts = self.SpinJmruiDataPoints.GetValue()
        apod = self.FloatJmruiApodize.GetValue()
        b0 = float(self.experiment.b0)
        nucleus = self.experiment.isotope
        broad = self.ChoiceJmruiLineshape.GetStringSelection()
        dwell = 1.0 / sw

        if nucleus == "1H":
            resppm = common_constants.DEFAULT_PROTON_CENTER_PPM     # 4.7
        else:
            resppm = common_constants.DEFAULT_XNUCLEI_CENTER_PPM    # 0.0

        path = self.LabelFilename.GetLabel()

        # parse metabolites in dynanic list into time FID data

        for vals in output_list:

            abbr = vals["abbr"]
            fout = os.path.join(path+'_'+abbr+'.nii')

            # data - numpy array with Npts in it, data.shape = npts,
            time = _make_basis(vals, metabs_dict, npts, sw, apod, broad, b0, resppm, False)
            newshape = (1, 1, 1) + time.shape
            time = time.reshape(newshape)

            # had to set encoding='utf-8' in definitions.py line 21 .read_text(encoding='utf-8')
            # confused by gen_nifti_mrs_hdr_ext(data, dwelltime, meta, nifti_orientation.Q44, no_conj=True)
            #   in create_nmrs.py, appears that conj() is applied when True

            conversion_time = datetime.now().isoformat(sep='T', timespec='milliseconds')

            # Interpret required arguments (frequency and bandwidth)
            meta = Hdr_Ext(b0, nucleus)
            meta.set_standard_def('ConversionMethod', 'nifti_mrs_vespa_simulation_export')
            meta.set_standard_def('ConversionTime', conversion_time)
            meta.set_standard_def('OriginalFile', ['vespa_simulation', ])

            if lines:
                meta.set_user_def('VespaComment', lines,
                                  'Provenance text from Vespa-Simulation third party output to NIfTI-MRS')

            # Default affine only for now
            affine = np.diag(np.array([10000, 10000, 10000, 1]))
            nifti_orientation = NIFTIOrient(affine)

            img = gen_nifti_mrs_hdr_ext(time, dwell, meta, nifti_orientation.Q44, no_conj=True)
            img.save(fout)

        bob = 10







###############################################################################
##### Dynamic Output List Class ###############################################

class DynamicOutputList(object):

    def __init__(self, parent, metabolite_grid_sizer, metabolites, local):
        
        self.parent = parent
        self.local  = local
        
        # We follow the wx CamelCaps naming convention for this wx object.
        self.MetaboliteGridSizer = metabolite_grid_sizer
                
        self.list_lines = []

        self.maxppm = self.local.pts2ppm(0)
#        self.minppm = self.local.pts2ppm(self.local.dims[0]-1)
        self.minppm = self.local.pts2ppm(self.local.spectral_dims[0]-1)

        self.names = [metabolite.name for metabolite in metabolites]
        self.nspins = [len(metabolite.spins) for metabolite in metabolites]
    
        for abbr_name in self.names:
            self.add_row(abbr_name)

    
    def add_row(self, abbr_name=None, mixture=None):
        """
        Adds a row to the end of the list. Mixture, if given, should be
        a list of 2-tuples of (mixture name, scale).
        """
        if abbr_name == None:
            abbr_name = self.names[0]
            
        # parse the mixture dialog values if necessary
        if mixture:
            nspins = 0
            names = []
            for line in mixture:
                names.append(line[0])
                nspins = nspins + self.nspins[self.names.index(line[0])]
            names = ['+'.join(names)]  
        else:
            names = self.names
            nspins = self.nspins[self.names.index(abbr_name)]

        # create widgets to go into the line
        list_line = { }
        check = wx.CheckBox(self.parent)
        combo_metabolites = wx.Choice(self.parent, choices=names)
        abbr = wx.TextCtrl(self.parent)
        # I want this text control to expand horizontally as the dialog grows
        # so I set the wx.EXPAND flag on it when I add it to the sizer. 
        # However, this also makes it expand vertically which makes it taller
        # than all of its neighbors.
        # To prevent that, I get its current height (before being added to the
        # sizer) and force that to be the max.
        _, height = abbr.GetSize()
        abbr.SetMaxSize( (-1, height) )
        
        scale  = FloatSpinMultiplier(self.parent, increment=1.25, digits=5, 
                                     style=wx.SP_ARROW_KEYS|wx.SP_WRAP|wx.TE_PROCESS_ENTER, 
                                     agwStyle=FS_LEFT)
        shift  = FloatSpin(self.parent, agwStyle=FS_LEFT)
        ppmstr = FloatSpin(self.parent, agwStyle=FS_LEFT)
        ppmend = FloatSpin(self.parent, agwStyle=FS_LEFT)
        
        # keep a copy of panel and widgets to access later
        line = { "checkbox"     : check, 
                 "metabolites"  : combo_metabolites,
                 "abbr"         : abbr, 
                 "scale"        : scale, 
                 "shift"        : shift,
                 "range_start"  : ppmstr, 
                 "range_end"    : ppmend,
                 "mixture"      : mixture, 
                 "nspins"       : nspins,       # just an FYI entry
               } 

        # Add the controls to the grid sizer
        self.MetaboliteGridSizer.SetRows(self.MetaboliteGridSizer.GetRows() + 1)

        self.MetaboliteGridSizer.Add(line["checkbox"], 0, wx.ALIGN_CENTER_VERTICAL)
        for key in ("metabolites", "abbr", "scale", "shift", "range_start",
                    "range_end"):
            self.MetaboliteGridSizer.Add(line[key], 0, wx.EXPAND)
        

        # Configure the controls I just created
        combo_metabolites.SetMinSize((100, -1))
        # Selecting the correct string is done a bit oddly. The combobox holds
        # either a list of the experiment's metabs or a single item 
        # representing a metab mixture. In the first case the abbreviated
        # name will match one of the metabs, otherwise it's correct to 
        # select the 0th (and only) item in the combobox.
        i = combo_metabolites.FindString(abbr_name)
        if i == wx.NOT_FOUND:
            i = 0
        combo_metabolites.SetSelection(i)
        
        abbr.SetValue(abbr_name)
        
        # All of the floatspins have the same size. 
        floatspin_size = wx.Size(90, -1)

        # Note. On these Spin and FloatSpin widgets, if the value you want to
        #    set is outside the wxGlade standard range, you should make the 
        #    call to reset the range first and then set the value you want.
        scale.multiplier = 1.25
        scale.SetDigits(5)
        scale.SetIncrement(1.0)
        scale.SetRange(0.00001,100000.0)
        scale.SetValue(1.0)
        scale.SetMinSize(floatspin_size)
        
        shift.SetDigits(3)
        shift.SetIncrement(0.1)
        shift.SetRange(-1000.0,1000.0)
        shift.SetValue(0.0)
        shift.SetMinSize(floatspin_size) 

        ppmstr.SetDigits(3)
        ppmstr.SetIncrement(0.1)
        ppmstr.SetRange(self.minppm,self.maxppm)
        ppmstr.SetValue(self.minppm)
        ppmstr.SetMinSize(floatspin_size)

        ppmend.SetDigits(3)
        ppmend.SetIncrement(0.1)
        ppmend.SetRange(self.minppm,self.maxppm)
        ppmend.SetValue(self.maxppm)
        ppmend.SetMinSize(floatspin_size)

        self.list_lines.append(line)
        
        self.parent.Layout()
        self.parent.Fit()
        
        
    def remove_checked_rows(self):
        # gather indices of all checked boxes
        checklist = []
        
        for i, line in enumerate(self.list_lines):
            if line["checkbox"].GetValue():
                checklist.append(i)
        
        # remove in reverse order so we don't invalidate later
        # indices by removing the ones preceding them in the list
        checklist.reverse()
        
        for i in checklist:
            # Each line is a dict of controls + mixture info
            for item in list(self.list_lines[i].values()):
                if hasattr(item, "Destroy"):
                    # It's a wx control
                    item.Destroy()
                
            del self.list_lines[i]
            
        # Reduce the # of rows in the grid sizer
        rows = self.MetaboliteGridSizer.GetRows()
        self.MetaboliteGridSizer.SetRows(rows - len(checklist))
        self.MetaboliteGridSizer.Layout()
        
        
    def get_values(self):
        return [self.get_line_values(line) for line in self.list_lines]


    def get_abbr(self):
        vals = self.get_values()
        return [line['abbr'] for line in vals]


    def get_line_values(self, line):
        # Returns a dict containing the values of six of the controls in a 
        # given line.
        # Also appended are the mixture values for a total of seven items
        # in the list.
        return { "metabolite"   : line["metabolites"].GetStringSelection(),
                 "abbr"         : line["abbr"].GetValue(),
                 "scale"        : line["scale"].GetValue(),
                 "shift"        : line["shift"].GetValue(),
                 "range_start"  : line["range_start"].GetValue(),
                 "range_end"    : line["range_end"].GetValue(),
                 "mixture"      : line["mixture"],
                 "nspins"       : line["nspins"],
               }

        
    def select_all(self):
        for line in self.list_lines:
            line["checkbox"].SetValue(True)

        
    def deselect_all(self):
        for line in self.list_lines:
            line["checkbox"].SetValue(False)
   
   
    def update_ppm_range(self, npts, sw):

        save_dim0 = self.local.spectral_dims[0]
        save_sw = self.local.sw
        self.local.spectral_dims[0] = npts
        self.local.sw = sw
        
        self.maxppm = self.local.pts2ppm(0)
        self.minppm = self.local.pts2ppm(self.local.spectral_dims[0]-1)
        
        for line in self.list_lines:
            ppmstr = line['range_start']
            ppmend = line['range_end']
            ppmstr.SetRange(self.minppm,self.maxppm)
            ppmend.SetRange(self.minppm,self.maxppm)
    
        self.local.spectral_dims[0] = save_dim0
        self.local.sw = save_sw

        
    def set_max_ppm_range(self, npts, sw):
        """
        Given a sweep width, sw, number of spectral points, npts, we
        calculate the minimum and maximum PPM values allowed in the spectral
        range. We then set the Start and End of Range widgets to these
        values.
        
        Note. For some npts, sw pairs we found that setting the Value to 
        the self.maxppm value exceeded the range set in the SetRange line,
        even though it was the same float value. This is likely due to 
        float precision error in the FloatSpinControl widget. We solve this
        for these PPM ranges by subtracting/adding a very small amount from
        the value set so as to ensure that we are always within the min/max
        range.
        
        """
        save_dim0 = self.local.spectral_dims[0]
        save_sw = self.local.sw
        self.local.spectral_dims[0] = npts
        self.local.sw = sw
        
        self.maxppm = self.local.pts2ppm(0)
        self.minppm = self.local.pts2ppm(self.local.spectral_dims[0]-1)
        
        for line in self.list_lines:
            ppmstr = line['range_start']
            ppmend = line['range_end']
            ppmstr.SetRange(self.minppm,self.maxppm)
            ppmend.SetRange(self.minppm,self.maxppm)
            ppmstr.SetValue(self.minppm + 0.00001)
            ppmend.SetValue(self.maxppm - 0.00001)
    
        self.local.spectral_dims[0] = save_dim0
        self.local.sw = save_sw        
        

