<vespa_export version="1.0.0">
	<!--
This XML file is in Vespa Interchange File Format (VIFF). You can download
applications that read and write VIFF files and learn more about VIFF here:
https://github.com/vespa-mrs/vespa/tree/main/vespa

It was created with Vespa version 1.0.0 (bjs tweaks).
-->
	<timestamp>2021-03-07T20:42:24</timestamp>
	<comment>This is the master file for populating the database.</comment>
	<pulse_sequence id="70457753-4a19-400c-8394-5edfd1bjs100" version="1.0.0">
		<name>CP-PRESS with Variable R-groups</name>
		<created>2021-03-07T20:51:46</created>
		<creator>Brian Soher</creator>
		<comment>This is an example PyGAMMA pulse sequence for use in Vespa-Simulation

This simulates a PRESS single voxel MRS pulse sequence which can have zero or more groups of refocussing pulses applied between the 1st and 2nd 180 degree pulse. The purpose of these refocussing pulses is to maintain the spins in a CPMG condition (CP = Carr-Purcell) which inhibits the effects of J-coupling effects on weakly coupled resonance groups like myo-Ins, glutamate, glutamine and GABA. 

Thus, while the TE for the PRESS sequence is calculated as TE1+TE2, where TE1 = time from 90 to first spin echo after first 180 pulse, and where TE2 = time from first spin echo to second spin echo after second 180 pulse, the TEeffective for CP-PRESS includes TE1+TE2+Tcp, where Tcp is the total time of the Carr-Purcell refocussing pulse train.

While TE1+TE2 is kept short (say 30ms), the Tcp can be lengthened (say 250ms) to yield an effective TE of 280ms. The multiplet patterns for weakly coupled resonance groups will look very similar to that of TE=30 ms, despite an effective TE of 280 ms. The longer effective TE allows short T1 signal contributions, such as residual water or lipids, to decay away.

Below, the pulse_type variable can be set to create a CP refocussing train of Ideal PyGAMMA 180 degree pulses or a CP train of MLEV16 sandwich pulses.

If sandwich pulses are selected, then the 'ang90' variable represents the angle of the alpha/2 pulse in the MLEV16 train, and 'pd90' is the duration of the alpha/2 pulse. In this simulation, TE1 period, TE2 period and number of refocussing groups can be varied, and the variables 'te1', 'te2' and 'rgroups' respectively, are taken from the settings for loop variables 1, 2 and 3. The r-group variable is so named for historical reasond (refocussing pulse groups). 

The variable tauR can be set to a fixed amount of time that separates the application of R-groups within the MLEV16 train. This mimics the operation of the pulse sequence on the scanner where it is sometimes necessary to space out RF pulses to lower the SAR during data acquisition.

</comment>
		<loop_label>TE1 [ms]</loop_label>
		<loop_label>TE2 [ms]</loop_label>
		<loop_label>Rgroups [int]</loop_label>
		<user_static_parameter>
			<name>Pulse Type (0-Ideal/1-Sandwich)</name>
			<type>Long</type>
			<default>1</default>
		</user_static_parameter>
		<user_static_parameter>
			<name>alpha/2 Pulse Angle [deg]</name>
			<type>Double</type>
			<default>100.0</default>
		</user_static_parameter>
		<user_static_parameter>
			<name>alpha/2 Pulse Duration [ms]</name>
			<type>Double</type>
			<default>0.5</default>
		</user_static_parameter>
		<user_static_parameter>
			<name>tauR Pulse Duration [ms]</name>
			<type>Double</type>
			<default>3.0</default>
		</user_static_parameter>
		<sequence_code>#-----------------------------------------------------------------------------
# This is an PyGAMMA PyGamma pulse sequence for use in Vespa-Simulation
#
# This simulates a PRESS single voxel MRS pulse sequence which can have
# zero or more groups of refocussing pulses applied between the 1st and
# 2nd 180 degree pulse. The purpose of these refocussing pulses is to
# maintain the spins in a CPMG condition which inhibits the effects of
# J-coupling effects on weakly coupled resonance groups like myo-Ins,
# glutamate, glutamine and GABA.
#
# Thus, while the TE for the PRESS sequence is calculated as TE1+TE2,
# where TE1 = time from 90 to first spin echo after first 180 pulse, and
# where TE2 = time from first spin echo to second spin echo after second
# 180 pulse, the TEeffective for CP-PRESS includes TE1+TE2+Tcp, where
# Tcp is the total time of the Carr-Purcell refocussing pulse train.
#
# While TE1+TE2 is kept short (say 30ms), the Tcp can be lengthened (say
# 250ms) to yield an effective TE of 280ms. The multiplet patterns for
# weakly coupled resonance groups will look very similar to that of TE=30
# ms, despite an effective TE of 280 ms. The longer effective TE allows
# short T1 signal contributions, such as residual water or lipids, to decay
# away.
#
# Below, the pulse_type variable can be set create a CP refocussing train of
# Ideal PyGAMMA 180 degree pulses or a CP train of MLEV16 sandwich pulses.
#
# If sandwich pulses are selected, then the ang90 variable represents the
# angle of the alpha/2 pulse in the MLEV16 train, and pd90 is the duration of
# the alpha/2 pulse. In this simulation, TE1 period, TE2 period and number of
# refocussing groups can be varied, and the variables 'te1', 'te2' and
# 'rgroups' respectively, are taken from the settings for loop variables 1, 2
# and 3.
#
# The r-group variable is so named for historical reasond (refocussing pulse
# groups).
#
# The variable tauR can be set to a fixed amount of time that separates the
# application of R-groups within the MLEV16 train. This mimics the operation
# of the pulse sequence on the scanner where it is sometimes necessary to
# space out RF pulses to lower the SAR during data acquisition.
#-----------------------------------------------------------------------------
import pygamma as pg


def run(sim_desc):
    spin_system = sim_desc.spin_system

    # the isotope string used to sort/select the metabolites of interest is passed 
    # in the sim_desc object so the user can tailor other object within their 
    # code to be nuclei specific, such as the observe operator or pulses
    obs_iso = sim_desc.observe_isotope

    # extract the dynamically changing variable from loops 1, 2 and 3, divide
    # 'te1' and 'te2' by 1000.0 because the GUI states that values are entered
    # in [ms], but PyGAMMA wants [sec]

    te1     = sim_desc.dims[1] / 1000.0
    te2     = sim_desc.dims[2] / 1000.0
    rgroups = int(sim_desc.dims[3])

    # extract user static parameter values from the control dictionary. They
    # are inserted into a list in the order that they are shown in the GUI.

    pulse_type = int(  sim_desc.user_static_parameters[0])
    ang90      = float(sim_desc.user_static_parameters[1])
    pd90       = float(sim_desc.user_static_parameters[2])
    tauR       = float(sim_desc.user_static_parameters[3])

    pd180   = pd90 * 2.0
    ang180  = ang90 * 2.0
    offhz   = 0.0

    # set up steady state and observation variables
    H   = pg.Hcs(spin_system) + pg.HJ(spin_system)
    D   = pg.Fm(spin_system, obs_iso)
    ac  = pg.acquire1D(pg.gen_op(D), H, 0.000001)
    ACQ = ac

    # apply excitation pulse and propagate to first 180 pulse
    sigma0 = pg.sigma_eq(spin_system)
    sigma1 = pg.Iypuls(spin_system, sigma0, obs_iso, 90.0)

    Udelay = pg.prop(H, te1*0.5)
    sigma0 = pg.evolve(sigma1, Udelay)

    # apply first 180 pulse and propagate to CP train start
    sigma1 = pg.Iypuls(spin_system, sigma0, obs_iso, 180.0)

    Udelay = pg.prop(H, te1*0.5)
    sigma0 = pg.evolve(sigma1, Udelay)

    sigma1 = sigma0

    # apply the Carr-Purcell refocussing pulse train
    if pulse_type == 0:

        # using Ideal 180 pulses
        for k in range(rgroups):
            Udelay = pg.prop(H, tauR/2.0)
            sigma0 = pg.evolve(sigma1,Udelay)

            sigma1 = pg.Iypuls(spin_system, sigma0, obs_iso, 180)

            Udelay = pg.prop(H, tauR/2.0)
            sigma0 = pg.evolve(sigma1,Udelay)

            sigma1 = sigma0
    else:

        for k in range(rgroups):

            # using 90-180-90 square 'Sandwich' pulses with MLEV16 phase 
            # cycling
            if (k % 4) == 0:

                Udelay = pg.prop(H, tauR/2.0)
                sigma0 = pg.evolve(sigma1,Udelay)

                sigma1 = pg.Sxpuls(spin_system, sigma0, H, obs_iso, offhz, pd90,  ang90)
                sigma0 = pg.Sypuls(spin_system, sigma1, H, obs_iso, offhz, pd180, ang180)
                sigma1 = pg.Sxpuls(spin_system, sigma0, H, obs_iso, offhz, pd90,  ang90)

                Udelay = pg.prop(H, tauR)
                sigma0 = pg.evolve(sigma1,Udelay)

                sigma1 = pg.Sxpuls(spin_system, sigma0, H, obs_iso, offhz, pd90,  ang90)
                sigma0 = pg.Sypuls(spin_system, sigma1, H, obs_iso, offhz, pd180, ang180)
                sigma1 = pg.Sxpuls(spin_system, sigma0, H, obs_iso, offhz, pd90,  ang90)

                Udelay = pg.prop(H, tauR)
                sigma0 = pg.evolve(sigma1,Udelay)

                sigma1 = pg.Sxpuls(spin_system, sigma0, H, obs_iso, offhz, pd90,  -ang90)
                sigma0 = pg.Sypuls(spin_system, sigma1, H, obs_iso, offhz, pd180, -ang180)
                sigma1 = pg.Sxpuls(spin_system, sigma0, H, obs_iso, offhz, pd90,  -ang90)

                Udelay = pg.prop(H, tauR)
                sigma0 = pg.evolve(sigma1,Udelay)

                sigma1 = pg.Sxpuls(spin_system, sigma0, H, obs_iso, offhz, pd90,  -ang90)
                sigma0 = pg.Sypuls(spin_system, sigma1, H, obs_iso, offhz, pd180, -ang180)
                sigma1 = pg.Sxpuls(spin_system, sigma0, H, obs_iso, offhz, pd90,  -ang90)

                Udelay = pg.prop(H, tauR/2.0)
                sigma0 = pg.evolve(sigma1,Udelay)

                sigma1 = sigma0

            if (k % 4) == 1:

                Udelay = pg.prop(H, tauR/2.0)
                sigma0 = pg.evolve(sigma1,Udelay)

                sigma1 = pg.Sxpuls(spin_system, sigma0, H, obs_iso, offhz, pd90,  -ang90)
                sigma0 = pg.Sypuls(spin_system, sigma1, H, obs_iso, offhz, pd180, -ang180)
                sigma1 = pg.Sxpuls(spin_system, sigma0, H, obs_iso, offhz, pd90,  -ang90)

                Udelay = pg.prop(H, tauR)
                sigma0 = pg.evolve(sigma1,Udelay)

                sigma1 = pg.Sxpuls(spin_system, sigma0, H, obs_iso, offhz, pd90,  ang90)
                sigma0 = pg.Sypuls(spin_system, sigma1, H, obs_iso, offhz, pd180, ang180)
                sigma1 = pg.Sxpuls(spin_system, sigma0, H, obs_iso, offhz, pd90,  ang90)

                Udelay = pg.prop(H, tauR)
                sigma0 = pg.evolve(sigma1,Udelay)

                sigma1 = pg.Sxpuls(spin_system, sigma0, H, obs_iso, offhz, pd90,  ang90)
                sigma0 = pg.Sypuls(spin_system, sigma1, H, obs_iso, offhz, pd180, ang180)
                sigma1 = pg.Sxpuls(spin_system, sigma0, H, obs_iso, offhz, pd90,  ang90)

                Udelay = pg.prop(H, tauR)
                sigma0 = pg.evolve(sigma1,Udelay)

                sigma1 = pg.Sxpuls(spin_system, sigma0, H, obs_iso, offhz, pd90,  -ang90)
                sigma0 = pg.Sypuls(spin_system, sigma1, H, obs_iso, offhz, pd180, -ang180)
                sigma1 = pg.Sxpuls(spin_system, sigma0, H, obs_iso, offhz, pd90,  -ang90)

                Udelay = pg.prop(H, tauR/2.0)
                sigma0 = pg.evolve(sigma1,Udelay)

                sigma1 = sigma0

            if (k % 4) == 2:

                Udelay = pg.prop(H, tauR/2.0)
                sigma0 = pg.evolve(sigma1,Udelay)

                sigma1 = pg.Sxpuls(spin_system, sigma0, H, obs_iso, offhz, pd90,  -ang90)
                sigma0 = pg.Sypuls(spin_system, sigma1, H, obs_iso, offhz, pd180, -ang180)
                sigma1 = pg.Sxpuls(spin_system, sigma0, H, obs_iso, offhz, pd90,  -ang90)

                Udelay = pg.prop(H, tauR)
                sigma0 = pg.evolve(sigma1,Udelay)

                sigma1 = pg.Sxpuls(spin_system, sigma0, H, obs_iso, offhz, pd90,  -ang90)
                sigma0 = pg.Sypuls(spin_system, sigma1, H, obs_iso, offhz, pd180, -ang180)
                sigma1 = pg.Sxpuls(spin_system, sigma0, H, obs_iso, offhz, pd90,  -ang90)

                Udelay = pg.prop(H, tauR)
                sigma0 = pg.evolve(sigma1,Udelay)

                sigma1 = pg.Sxpuls(spin_system, sigma0, H, obs_iso, offhz, pd90,  ang90)
                sigma0 = pg.Sypuls(spin_system, sigma1, H, obs_iso, offhz, pd180, ang180)
                sigma1 = pg.Sxpuls(spin_system, sigma0, H, obs_iso, offhz, pd90,  ang90)

                Udelay = pg.prop(H, tauR)
                sigma0 = pg.evolve(sigma1,Udelay)

                sigma1 = pg.Sxpuls(spin_system, sigma0, H, obs_iso, offhz, pd90,  ang90)
                sigma0 = pg.Sypuls(spin_system, sigma1, H, obs_iso, offhz, pd180, ang180)
                sigma1 = pg.Sxpuls(spin_system, sigma0, H, obs_iso, offhz, pd90,  ang90)

                Udelay = pg.prop(H, tauR/2.0)
                sigma0 = pg.evolve(sigma1,Udelay)

                sigma1 = sigma0

            if (k % 4) == 3:

                Udelay = pg.prop(H, tauR/2.0)
                sigma0 = pg.evolve(sigma1,Udelay)

                sigma1 = pg.Sxpuls(spin_system, sigma0, H, obs_iso, offhz, pd90,  ang90)
                sigma0 = pg.Sypuls(spin_system, sigma1, H, obs_iso, offhz, pd180, ang180)
                sigma1 = pg.Sxpuls(spin_system, sigma0, H, obs_iso, offhz, pd90,  ang90)

                Udelay = pg.prop(H, tauR)
                sigma0 = pg.evolve(sigma1,Udelay)

                sigma1 = pg.Sxpuls(spin_system, sigma0, H, obs_iso, offhz, pd90,  -ang90)
                sigma0 = pg.Sypuls(spin_system, sigma1, H, obs_iso, offhz, pd180, -ang180)
                sigma1 = pg.Sxpuls(spin_system, sigma0, H, obs_iso, offhz, pd90,  -ang90)

                Udelay = pg.prop(H, tauR)
                sigma0 = pg.evolve(sigma1,Udelay)

                sigma1 = pg.Sxpuls(spin_system, sigma0, H, obs_iso, offhz, pd90,  -ang90)
                sigma0 = pg.Sypuls(spin_system, sigma1, H, obs_iso, offhz, pd180, -ang180)
                sigma1 = pg.Sxpuls(spin_system, sigma0, H, obs_iso, offhz, pd90,  -ang90)

                Udelay = pg.prop(H, tauR)
                sigma0 = pg.evolve(sigma1,Udelay)

                sigma1 = pg.Sxpuls(spin_system, sigma0, H, obs_iso, offhz, pd90,  ang90)
                sigma0 = pg.Sypuls(spin_system, sigma1, H, obs_iso, offhz, pd180, ang180)
                sigma1 = pg.Sxpuls(spin_system, sigma0, H, obs_iso, offhz, pd90,  ang90)

                Udelay = pg.prop(H, tauR/2.0)
                sigma0 = pg.evolve(sigma1,Udelay)

                sigma1 = sigma0

    # propagate to second 180 pulse
    Udelay = pg.prop(H, te2*0.5)
    sigma0 = pg.evolve(sigma1, Udelay)

    # apply second 180 pulse and propagate to data acquisition
    sigma1 = pg.Iypuls(spin_system, sigma0, obs_iso, 180.0)

    Udelay = pg.prop(H, te2*0.5)
    sigma0 = pg.evolve(sigma1, Udelay)

    # instantiate and save the transition table of simulation results
    # note. this step copies the TTable1D result from the ACQ into
    #       a TTable1D object in the sim_desc object. Thus, when
    #       we return from this function and the ACQ variable gets
    #       garbage collected, our copy of the results in not affected
    sim_desc.mx = pg.TTable1D(ACQ.table(sigma0))
</sequence_code>
		<binning_code>import pygamma as pg
import numpy as np

def run(sim_desc):
    area   = pg.DoubleVector(0)
    ppm    = pg.DoubleVector(0)
    phase  = pg.DoubleVector(0)
    field  = sim_desc.field             # freq in MHz
    nspins = sim_desc.nspins
    tolppm = sim_desc.blend_tolerance_ppm
    tolpha = sim_desc.blend_tolerance_phase
    ppmlo  = sim_desc.peak_search_ppm_low
    ppmhi  = sim_desc.peak_search_ppm_high

    sys     = sim_desc.spin_system
    obs_iso = sim_desc.observe_isotope
    nlines  = sim_desc.mx.size()

    # Scaling is based on the quantum number of each spin, the qnStates.size
    # method sums 2*qn[i]+1 and then we divide by 2*qn[observe]+1 of the
    # observe spin.  This gets us back to the 'physics' norm where values are
    # =/- 1/2, so then we multiply by 2.0 to get values of 1.0 for each spin 
    # that is being normalized here.
    
    obs_qn  = pg.Isotope(obs_iso).qn()
    qnscale = sys.qnStates().size()
    qnscale = qnscale / (2.0 * (2.0*obs_qn+1))

    freqs = []
    outf  = []
    outa  = []
    outp  = []
    nbin  = 0
    found = False

    PI = 3.14159265358979323846
    RAD2DEG = 180.0/PI

    # Based on TTable1D::calc_spectra() ---------------------------------------

    indx = sim_desc.mx.Sort(0,-1,0)

    for i in range(nlines):
        freqs.append(-1 * sim_desc.mx.Fr(indx[i])/(2.0*PI*field))

    for i in range(nlines):
        freq = freqs[i]
        if (freq &gt; ppmlo) and (freq &lt; ppmhi):
            val = sim_desc.mx.I(indx[i])
            tmpa = np.sqrt(val.real()**2 + val.imag()**2) / qnscale  #normal
            tmpp = -RAD2DEG * np.angle(val.real()+1j*val.imag())

        if nbin == 0:
            outf.append(freq)
            outa.append(tmpa)
            outp.append(tmpp)
            nbin += 1
        else:
            for k in range(nbin):
                if (freq &gt;= outf[k]-tolppm) and (freq &lt;= outf[k]+tolppm):
                    if (tmpp &gt;= outp[k]-tolpha) and (tmpp &lt;= outp[k]+tolpha):
                        ampsum   =  outa[k]+tmpa
                        outf[k]  = (outa[k]*outf[k] + tmpa*freq)/ampsum
                        outp[k]  = (outa[k]*outp[k] + tmpa*tmpp)/ampsum
                        outa[k] +=  tmpa;
                        found = True
            if not found:
                outf.append(freq)
                outa.append(tmpa)
                outp.append(tmpp)
                nbin += 1
            found = False

    ppm.resize(nbin)
    area.resize(nbin)
    phase.resize(nbin)

    for i in range(nbin):
        ppm[i]   = outf[i]
        area[i]  = outa[i]
        phase[i] = -1.0*outp[i]

    return (ppm, area, phase)
</binning_code>
	</pulse_sequence>
	<pulse_sequence id="a5e5606d-5527-4ac6-b063-8894d5bjs100" version="1.0.0">
		<name>JPRESS Ideal</name>
		<created>2021-03-07T20:50:28</created>
		<creator>Brian Soher</creator>
		<comment>This is an example PyGAMMA pulse sequence for use in Vespa-Simulation

A timing diagram for this pulse sequence can be found in the Appendix of the Simulation User Manual.
</comment>
		<loop_label>TE [ms]</loop_label>
		<sequence_code>import pygamma as pg


def run(sim_desc):
    #------------------------------------------------------------------------
    # This is an example PyGAMMA pulse sequence for use in Vespa-Simulation
    #
    # A timing diagram for this pulse sequence can be found in the Appendix 
    # of the Simulation User Manual.
    #-----------------------------------------------------------------------

    spin_system = sim_desc.spin_system

    # the isotope string used to sort/select the metabolites of interest is passed 
    # in the sim_desc object so the user can tailor other object within their 
    # code to be nuclei specific, such as the observe operator or pulses
    obs_iso = sim_desc.observe_isotope

    # extract the dynamically changing variable from loop 1, divide by 1000.0
    # because the GUI states that values are entered in [ms], but PyGAMMA 
    # wants [sec]

    te = sim_desc.dims[1] / 1000.0

    # set up steady state and observation variables
    H   = pg.Hcs(spin_system) + pg.HJ(spin_system) 
    D   = pg.Fm(spin_system, obs_iso) 
    ac  = pg.acquire1D(pg.gen_op(D), H, 0.000001) 
    ACQ = ac 

    # apply excitation and refocusing pulses and propagate 

    sigma0 = pg.sigma_eq(spin_system) 
    sigma1 = pg.Ixpuls(spin_system, sigma0, obs_iso, 90.0)
    Udelay = pg.prop(H, te*0.25)
    sigma0 = pg.evolve(sigma1, Udelay)
    sigma1 = pg.Iypuls(spin_system, sigma0, obs_iso, 180.0)
    Udelay = pg.prop(H, te*0.25)
    sigma0 = pg.evolve(sigma1, Udelay)
    sigma1 = pg.Iypuls(spin_system, sigma0, obs_iso, 90.0)
    Udelay = pg.prop(H, te*0.25)
    sigma0 = pg.evolve(sigma1, Udelay)
    sigma1 = pg.Iypuls(spin_system, sigma0, obs_iso, 180.0)
    Udelay = pg.prop(H, te*0.25)
    sigma0 = pg.evolve(sigma1, Udelay)

    # instantiate and save transition table of simulation results
    # note. this step copies the TTable1D result from the ACQ into
    #       a TTable1D object in the sim_desc object. Thus, when
    #       we return from this function and the ACQ variable gets
    #       garbage collected, our copy of the results in not affected
    sim_desc.mx = pg.TTable1D(ACQ.table(sigma0))</sequence_code>
		<binning_code>import pygamma as pg
import numpy as np

def run(sim_desc):
    area   = pg.DoubleVector(0)
    ppm    = pg.DoubleVector(0)
    phase  = pg.DoubleVector(0)
    field  = sim_desc.field             # freq in MHz
    nspins = sim_desc.nspins
    tolppm = sim_desc.blend_tolerance_ppm
    tolpha = sim_desc.blend_tolerance_phase
    ppmlo  = sim_desc.peak_search_ppm_low
    ppmhi  = sim_desc.peak_search_ppm_high

    sys     = sim_desc.spin_system
    obs_iso = sim_desc.observe_isotope
    nlines  = sim_desc.mx.size()

    # Scaling is based on the quantum number of each spin, the qnStates.size
    # method sums 2*qn[i]+1 and then we divide by 2*qn[observe]+1 of the
    # observe spin.  This gets us back to the 'physics' norm where values are
    # =/- 1/2, so then we multiply by 2.0 to get values of 1.0 for each spin 
    # that is being normalized here.
    
    obs_qn  = pg.Isotope(obs_iso).qn()
    qnscale = sys.qnStates().size()
    qnscale = qnscale / (2.0 * (2.0*obs_qn+1))

    freqs = []
    outf  = []
    outa  = []
    outp  = []
    nbin  = 0
    found = False

    PI = 3.14159265358979323846
    RAD2DEG = 180.0/PI

    # Based on TTable1D::calc_spectra() ---------------------------------------

    indx = sim_desc.mx.Sort(0,-1,0)

    for i in range(nlines):
        freqs.append(-1 * sim_desc.mx.Fr(indx[i])/(2.0*PI*field))

    for i in range(nlines):
        freq = freqs[i]
        if (freq &gt; ppmlo) and (freq &lt; ppmhi):
            val = sim_desc.mx.I(indx[i])
            tmpa = np.sqrt(val.real()**2 + val.imag()**2) / qnscale  #normal
            tmpp = -RAD2DEG * np.angle(val.real()+1j*val.imag())

        if nbin == 0:
            outf.append(freq)
            outa.append(tmpa)
            outp.append(tmpp)
            nbin += 1
        else:
            for k in range(nbin):
                if (freq &gt;= outf[k]-tolppm) and (freq &lt;= outf[k]+tolppm):
                    if (tmpp &gt;= outp[k]-tolpha) and (tmpp &lt;= outp[k]+tolpha):
                        ampsum   =  outa[k]+tmpa
                        outf[k]  = (outa[k]*outf[k] + tmpa*freq)/ampsum
                        outp[k]  = (outa[k]*outp[k] + tmpa*tmpp)/ampsum
                        outa[k] +=  tmpa;
                        found = True
            if not found:
                outf.append(freq)
                outa.append(tmpa)
                outp.append(tmpp)
                nbin += 1
            found = False

    ppm.resize(nbin)
    area.resize(nbin)
    phase.resize(nbin)

    for i in range(nbin):
        ppm[i]   = outf[i]
        area[i]  = outa[i]
        phase[i] = -1.0*outp[i]

    return (ppm, area, phase)
</binning_code>
	</pulse_sequence>
	<pulse_sequence id="28e07f4b-5d37-43e0-828d-4e7a73bjs100" version="1.0.0">
		<name>One-Pulse</name>
		<created>2021-03-07T20:39:42</created>
		<creator>Brian Soher</creator>
		<comment>This is an example PyGAMMA pulse sequence for use in Vespa-Simulation

A timing diagram for this pulse sequence can be found in the Appendix of the Simulation User Manual.
</comment>
		<sequence_code>import pygamma as pg

def run(sim_desc):
    #------------------------------------------------------------------------
    # This is an example PyGAMMA pulse sequence for use in Vespa-Simulation
    #
    # A timing diagram for this pulse sequence can be found in the Appendix 
    # of the Simulation User Manual.
    #------------------------------------------------------------------------
    spin_system = sim_desc.spin_system

    # the isotope string used to sort/select the metabolites of interest is passed 
    # in the sim_desc object so the user can tailor other object within their 
    # code to be nuclei specific, such as the observe operator or pulses
    obs_iso = sim_desc.observe_isotope

    # set up steady state and observation variables
    H   = pg.Hcs(spin_system) + pg.HJ(spin_system) 
    D   = pg.Fm(spin_system, obs_iso) 
    ac  = pg.acquire1D(pg.gen_op(D), H, 0.000001) 
    ACQ = ac 

    # excite and acquire the data
    sigma  = pg.sigma_eq(spin_system) 
    sigma0 = pg.Iypuls(spin_system, sigma, obs_iso, 90.0) 

    # instantiate and save transition table of simulation results
    # note. this step copies the TTable1D result from the ACQ into
    #       a TTable1D object in the sim_desc object. Thus, when
    #       we return from this function and the ACQ variable gets
    #       garbage collected, our copy of the results in not affected
    sim_desc.mx = pg.TTable1D(ACQ.table(sigma0))
</sequence_code>
		<binning_code>import pygamma as pg
import numpy as np

def run(sim_desc):
    area   = pg.DoubleVector(0)
    ppm    = pg.DoubleVector(0)
    phase  = pg.DoubleVector(0)
    field  = sim_desc.field             # freq in MHz
    nspins = sim_desc.nspins
    tolppm = sim_desc.blend_tolerance_ppm
    tolpha = sim_desc.blend_tolerance_phase
    ppmlo  = sim_desc.peak_search_ppm_low
    ppmhi  = sim_desc.peak_search_ppm_high

    sys     = sim_desc.spin_system
    obs_iso = sim_desc.observe_isotope
    nlines  = sim_desc.mx.size()

    # Scaling is based on the quantum number of each spin, the qnStates.size
    # method sums 2*qn[i]+1 and then we divide by 2*qn[observe]+1 of the
    # observe spin.  This gets us back to the 'physics' norm where values are
    # =/- 1/2, so then we multiply by 2.0 to get values of 1.0 for each spin 
    # that is being normalized here.
    
    obs_qn  = pg.Isotope(obs_iso).qn()
    qnscale = sys.qnStates().size()
    qnscale = qnscale / (2.0 * (2.0*obs_qn+1))

    freqs = []
    outf  = []
    outa  = []
    outp  = []
    nbin  = 0
    found = False

    PI = 3.14159265358979323846
    RAD2DEG = 180.0/PI

    # Based on TTable1D::calc_spectra() ---------------------------------------

    indx = sim_desc.mx.Sort(0,-1,0)

    for i in range(nlines):
        freqs.append(-1 * sim_desc.mx.Fr(indx[i])/(2.0*PI*field))

    for i in range(nlines):
        freq = freqs[i]
        if (freq &gt; ppmlo) and (freq &lt; ppmhi):
            val = sim_desc.mx.I(indx[i])
            tmpa = np.sqrt(val.real()**2 + val.imag()**2) / qnscale  #normal
            tmpp = -RAD2DEG * np.angle(val.real()+1j*val.imag())

        if nbin == 0:
            outf.append(freq)
            outa.append(tmpa)
            outp.append(tmpp)
            nbin += 1
        else:
            for k in range(nbin):
                if (freq &gt;= outf[k]-tolppm) and (freq &lt;= outf[k]+tolppm):
                    if (tmpp &gt;= outp[k]-tolpha) and (tmpp &lt;= outp[k]+tolpha):
                        ampsum   =  outa[k]+tmpa
                        outf[k]  = (outa[k]*outf[k] + tmpa*freq)/ampsum
                        outp[k]  = (outa[k]*outp[k] + tmpa*tmpp)/ampsum
                        outa[k] +=  tmpa;
                        found = True
            if not found:
                outf.append(freq)
                outa.append(tmpa)
                outp.append(tmpp)
                nbin += 1
            found = False

    ppm.resize(nbin)
    area.resize(nbin)
    phase.resize(nbin)

    for i in range(nbin):
        ppm[i]   = outf[i]
        area[i]  = outa[i]
        phase[i] = -1.0*outp[i]

    return (ppm, area, phase)
</binning_code>
	</pulse_sequence>
	<pulse_sequence id="97f8fa7c-33bf-4277-be78-49ce5cbjs100" version="1.0.0">
		<name>One-Pulse No Binning</name>
		<created>2021-03-07T20:49:29</created>
		<creator>Brian Soher</creator>
		<comment>This is an example PyGAMMA pulse sequence for use in Vespa-Simulation

A timing diagram for this pulse sequence can be found in the Appendix of the Simulation User Manual.
</comment>
		<sequence_code>import math

import pygamma as pg

def run(sim_desc):
    #------------------------------------------------------------------------
    # This is an example PyGAMMA pulse sequence for use in Vespa-Simulation.
    # It demonstrates how results can be returned directly by the sequence 
    # code as opposed to being returned by the binning code. When the
    # sequence code returns results, the binning code is never invoked.
    #
    # A timing diagram for this pulse sequence can be found in the Appendix 
    # of the Simulation User Manual.
    #------------------------------------------------------------------------
    spin_system = sim_desc.spin_system
    
    # the isotope string used to sort/select the metabolites of interest is passed 
    # in the sim_desc object so the user can tailor other object within their 
    # code to be nuclei specific, such as the observe operator or pulses
    obs_iso = sim_desc.observe_isotope

    # set up steady state and observation variables
    H   = pg.Hcs(spin_system) + pg.HJ(spin_system) 
    D   = pg.Fm(spin_system, obs_iso) 
    ac  = pg.acquire1D(pg.gen_op(D), H, 0.000001) 
    ACQ = ac 

    # excite and acquire the data
    sigma  = pg.sigma_eq(spin_system) 
    sigma0 = pg.Iypuls(spin_system, sigma, obs_iso, 90.0) 

    # instantiate transition table of simulation results
    mx = pg.TTable1D(ACQ.table(sigma0))

    # Calculate results
    mx_indices = mx.Sort(0, -1, 0)
    
    # Scaling is based on the quantum number of each spin, the qnStates.size
    # method sums 2*qn[i]+1 and then we divide by 2*qn[observe]+1 of the
    # observe spin.  This gets us back to the 'physics' norm where values are
    # =/- 1/2, so then we multiply by 2.0 to get values of 1.0 for each spin 
    # that is being normalized here.
    
    obs_qn  = pg.Isotope(obs_iso).qn()
    qnscale = spin_system.qnStates().size()
    normal = qnscale / (2.0 * (2.0*obs_qn+1))
    
    ppms = []
    areas = []
    phases = []
    
    for index in mx_indices:
        # ctmp is a complex number
        ctmp = mx.I(index)

        ppms.append(-mx.Fr(index) / (2.0 * math.pi * sim_desc.field))
        areas.append(math.hypot(ctmp.Rec(), ctmp.Imc()) / normal)

        if ctmp.Imc() or ctmp.Rec():
            phase = (-180.0 / math.pi) * math.atan2(ctmp.Imc(), ctmp.Rec())
        else:
            phase = 0

        phases.append(phase)

    phases = [(phase * -1.0) for phase in phases]

    return (ppms, areas, phases)
</sequence_code>
		<binning_code>def run(sim_desc):
    # Since results for this pulse sequence are returned by the sequence
    # code, this code won't be executed. Just to prove the point, we'll raise
    # an error if this code runs.
    
    raise NotImplementedError
</binning_code>
	</pulse_sequence>
	<pulse_sequence id="43be13ae-de9a-40a1-9a2d-c872d8bjs100" version="1.0.0">
		<name>PRESS Ideal</name>
		<created>2021-03-07T20:44:20</created>
		<creator>Brian Soher</creator>
		<comment>This is an example PyGAMMA pulse sequence for use in Vespa-Simulation

A timing diagram for this pulse sequence can be found in the Appendix of the Simulation User Manual.
</comment>
		<loop_label>TE1 [ms]</loop_label>
		<loop_label>TE2 [ms]</loop_label>
		<sequence_code>import pygamma as pg

def run(sim_desc):
    #----------------------------------------------------------------------
    # This is an example PyGAMMA pulse sequence for use in Vespa-Simulation
    #
    # A timing diagram for this pulse sequence can be found in the Appendix 
    # of the Simulation User Manual.
    #----------------------------------------------------------------------
    spin_system = sim_desc.spin_system

    # the isotope string used to sort/select the metabolites of interest is passed 
    # in the sim_desc object so the user can tailor other object within their 
    # code to be nuclei specific, such as the observe operator or pulses
    obs_iso = sim_desc.observe_isotope

    # extract the dynamically changing variable from loop 1 and 2 for 'te1' and
    # 'te2', divide by 1000.0 because the GUI states that values are entered in 
    # [ms], but PyGAMMA wants [sec]

    te1 = sim_desc.dims[1] / 1000.0 
    te2 = sim_desc.dims[2] / 1000.0

    # set up steady state and observation variables
    H   = pg.Hcs(spin_system) + pg.HJ(spin_system) 
    D   = pg.Fm(spin_system, obs_iso) 
    ac  = pg.acquire1D(pg.gen_op(D), H, 0.000001) 
    ACQ = ac 
    sigma0 = pg.sigma_eq(spin_system) 

    # excite, propagate, refocus and acquire the data
    sigma1 = pg.Iypuls(spin_system, sigma0, obs_iso, 90.0)
    Udelay = pg.prop(H, te1*0.5)
    sigma0 = pg.evolve(sigma1, Udelay)
    sigma1 = pg.Iypuls(spin_system, sigma0, obs_iso, 180.0)
    Udelay = pg.prop(H, (te1+te2)*0.5)
    sigma0 = pg.evolve(sigma1, Udelay)
    sigma1 = pg.Iypuls(spin_system, sigma0, obs_iso, 180.0)
    Udelay = pg.prop(H, te2*0.5)
    sigma0 = pg.evolve(sigma1, Udelay)

    # instantiate and save transition table of simulation results
    # note. this step copies the TTable1D result from the ACQ into
    #       a TTable1D object in the sim_desc object. Thus, when
    #       we return from this function and the ACQ variable gets
    #       garbage collected, our copy of the results in not affected
    sim_desc.mx = pg.TTable1D(ACQ.table(sigma0))
</sequence_code>
		<binning_code>import pygamma as pg
import numpy as np

def run(sim_desc):
    area   = pg.DoubleVector(0)
    ppm    = pg.DoubleVector(0)
    phase  = pg.DoubleVector(0)
    field  = sim_desc.field             # freq in MHz
    nspins = sim_desc.nspins
    tolppm = sim_desc.blend_tolerance_ppm
    tolpha = sim_desc.blend_tolerance_phase
    ppmlo  = sim_desc.peak_search_ppm_low
    ppmhi  = sim_desc.peak_search_ppm_high

    sys     = sim_desc.spin_system
    obs_iso = sim_desc.observe_isotope
    nlines  = sim_desc.mx.size()

    # Scaling is based on the quantum number of each spin, the qnStates.size
    # method sums 2*qn[i]+1 and then we divide by 2*qn[observe]+1 of the
    # observe spin.  This gets us back to the 'physics' norm where values are
    # =/- 1/2, so then we multiply by 2.0 to get values of 1.0 for each spin 
    # that is being normalized here.
    
    obs_qn  = pg.Isotope(obs_iso).qn()
    qnscale = sys.qnStates().size()
    qnscale = qnscale / (2.0 * (2.0*obs_qn+1))

    freqs = []
    outf  = []
    outa  = []
    outp  = []
    nbin  = 0
    found = False

    PI = 3.14159265358979323846
    RAD2DEG = 180.0/PI

    # Based on TTable1D::calc_spectra() ---------------------------------------

    indx = sim_desc.mx.Sort(0,-1,0)

    for i in range(nlines):
        freqs.append(-1 * sim_desc.mx.Fr(indx[i])/(2.0*PI*field))

    for i in range(nlines):
        freq = freqs[i]
        if (freq &gt; ppmlo) and (freq &lt; ppmhi):
            val = sim_desc.mx.I(indx[i])
            tmpa = np.sqrt(val.real()**2 + val.imag()**2) / qnscale  #normal
            tmpp = -RAD2DEG * np.angle(val.real()+1j*val.imag())

        if nbin == 0:
            outf.append(freq)
            outa.append(tmpa)
            outp.append(tmpp)
            nbin += 1
        else:
            for k in range(nbin):
                if (freq &gt;= outf[k]-tolppm) and (freq &lt;= outf[k]+tolppm):
                    if (tmpp &gt;= outp[k]-tolpha) and (tmpp &lt;= outp[k]+tolpha):
                        ampsum   =  outa[k]+tmpa
                        outf[k]  = (outa[k]*outf[k] + tmpa*freq)/ampsum
                        outp[k]  = (outa[k]*outp[k] + tmpa*tmpp)/ampsum
                        outa[k] +=  tmpa;
                        found = True
            if not found:
                outf.append(freq)
                outa.append(tmpa)
                outp.append(tmpp)
                nbin += 1
            found = False

    ppm.resize(nbin)
    area.resize(nbin)
    phase.resize(nbin)

    for i in range(nbin):
        ppm[i]   = outf[i]
        area[i]  = outa[i]
        phase[i] = -1.0*outp[i]

    return (ppm, area, phase)
</binning_code>
	</pulse_sequence>
	<pulse_sequence id="35384de1-b914-456a-8cda-4c610afd3552" version="1.0.0">
		<name>PRESS with real 180 pulses from Pulse</name>
		<created>2021-03-07T16:54:33</created>
		<creator>Brian Soher</creator>
		<comment>This is an example PyGAMMA pulse sequence for use in Vespa-Simulation

A timing diagram for this pulse sequence can be found in the Appendix of the Simulation User Manual.

This pulse sequence makes use of the simulation description attribute "pulses".

The "pulses" attribute is a list of "real" RF pulses that were copied from RFPulse projects in the Vespa databse. Each item in the list is an instance of the MinimalistPulse class. That class contains the pulse name (just for your information), the dwell time as a single float in microseconds (all waveforms are assumed to have evenly spaced time axis points), and the waveform as a list of complex floats in milliTesla. 

As shown in the sequence code, this waveform can be converted for the field strength and gyromagnetic ratio required and turned into a PyGAMMA PulWaveform and from there inserted into a PulComposite that can be used in the pulse sequence.

The formal definition of the MinimalistPulse class is in vespa/public/minimalist_pulse.py which you can view online here:
https://github.com/vespa-mrs/vespa/tree/main/vespa/public/minimalist_pulse.py
</comment>
		<loop_label>TE1 [ms]</loop_label>
		<loop_label>TE2 [ms]</loop_label>
		<pulse_design id="51312b68-7e98-4d45-b19a-586b056e4027" version="1.0.0">
			<name>Example - Adiabatic 180 for Simulation real pulse test</name>
			<created>2021-03-07T13:32:57</created>
			<creator>Brian J Soher</creator>
			<comment>This is a generic adiabatic 180 degree inversion pulse created in RFPulse with a duration of 8ms and a bandwidth of approximately 2kHz (+/- 1kHz). This is not an optimized pulse, just a demonstration.
</comment>
			<calc_resolution>5000</calc_resolution>
			<pulse_bandwidth_type>half_height</pulse_bandwidth_type>
			<gyromagnetic_nuclei>1H</gyromagnetic_nuclei>
			<machine_specs version="1.0.0">
				<machine_type>Whole Body MRI</machine_type>
				<field_strength>3.0</field_strength>
				<max_b1_field>22.0</max_b1_field>
				<zero_padding>0</zero_padding>
				<min_dwell_time>1.0</min_dwell_time>
				<dwell_time_increment>0.2</dwell_time_increment>
				<gradient_raster_time>10.0</gradient_raster_time>
				<gradient_slew_rate>200.0</gradient_slew_rate>
				<gradient_maximum>24.0</gradient_maximum>
			</machine_specs>
			<transform version="1.0.0">
				<transform_kernel id="4aa72529-5f0d-41b8-8762-0bf9870bd789" version="1.0.0">
					<type>Create Transform</type>
					<name>Matpulse Hyperbolic Secant</name>
					<menu_label>Matpulse - Hyperbolic Secant</menu_label>
					<created>2016-09-23T16:39:23</created>
					<creator>bjs</creator>
					<comment>Cloned 31 August, 2015 21:22:44 from 987d6443-f6e2-4d74-a729-0550653702c8 (Hypebolic Secant - Matpulse)
Cloned 18 November, 2015 17:05:26 from 8cad1526-ff81-43c6-a708-f4fd8f5cd63a (Hypebolic Secant - Matpulse)
Cloned 23 September, 2016 16:39:23 from d6b9efe0-1d85-43f4-871c-3b06aa637ec6 (Matpulse Hyperbolic Secant)
Modified 7 March, 2001 for version 1.0.0 release
    original name:       Matpulse Hyperbolic Secant multinuc
    original menu label: Matpulse Hyperbolic Secant multinuc
</comment>
					<hide_file1>true</hide_file1>
					<hide_file2>true</hide_file2>
					<hide_time_steps>false</hide_time_steps>
					<hide_duration>false</hide_duration>
					<hide_tip_angle>true</hide_tip_angle>
					<hide_bandwidth>true</hide_bandwidth>
					<file1_label />
					<file2_label />
					<tip_angle>90.0</tip_angle>
					<time_steps>250</time_steps>
					<duration>8.0</duration>
					<bandwidth>1.0</bandwidth>
					<deprecated>false</deprecated>
					<transform_kernel_control version="1.0.0">
						<name>Time Steps [int]</name>
						<type>Long</type>
						<default>250</default>
						<variable>time_steps</variable>
					</transform_kernel_control>
					<transform_kernel_control version="1.0.0">
						<name>Duration [msec]</name>
						<type>Double</type>
						<default>8.0</default>
						<variable>duration</variable>
					</transform_kernel_control>
					<transform_kernel_control version="1.0.0">
						<name>Total Rotation [deg]</name>
						<type>Double</type>
						<default>1440</default>
						<variable>total_rotation</variable>
					</transform_kernel_control>
					<transform_kernel_control version="1.0.0">
						<name>Cycles</name>
						<type>Double</type>
						<default>6.0</default>
						<variable>quality_cycles</variable>
					</transform_kernel_control>
					<transform_kernel_control version="1.0.0">
						<name>Power(n)</name>
						<type>Long</type>
						<default>1</default>
						<variable>power_n</variable>
					</transform_kernel_control>
					<transform_kernel_control version="1.0.0">
						<name>Sharpness(mu)</name>
						<type>Double</type>
						<default>4.0</default>
						<variable>sharpness_mu</variable>
					</transform_kernel_control>
					<transform_kernel_control version="1.0.0">
						<name>Filter Type</name>
						<type>Choice</type>
						<default>None,Cosine,Hamming</default>
						<variable>filter_type</variable>
					</transform_kernel_control>
					<transform_kernel_control version="1.0.0">
						<name>Filter Application [%]</name>
						<type>Double</type>
						<default>0.0</default>
						<variable>filter_application</variable>
					</transform_kernel_control>
					<transform_kernel_control version="1.0.0">
						<name>Dwell Time [usec]</name>
						<type>Output</type>
						<default>None</default>
						<variable>out_dwell_time</variable>
					</transform_kernel_control>
					<transform_kernel_control version="1.0.0">
						<name>Bandwidth [kHz]</name>
						<type>Output</type>
						<default>None</default>
						<variable>out_bandwidth</variable>
					</transform_kernel_control>
					<algorithm_code># Python Modules.
from __future__ import division
import copy
import math

# 3rd party stuff
import numpy as np
import scipy.integrate as integrate
import scipy.stats.distributions as distributions

# Local imports
import vespa.common.rfp_rf_result as rfp_rf_result
from vespa.common.transform_run_exception import TransformRunException


# Gyromagnetic ratio of 1H - the hydrogen nucleus. (units: kHz/mT)
# GAMMA1H = 42.576    



def run(trans_desc):
    """
    Script for pulse generation. Adjusts some input parameters to be in the 
    correct units.

    time_steps      - the number of data points in the output waveform
    dwell_time      - the spacing between points in microseconds.
    
    resolution      - the calculation resolution for frequency domain 
                      computations.
    bandwidth_convention:
        0 for "conventional" (default, FWHM)
        1 for spectroscopy convention (MINIMUM)
        2 for filter convention (MAXIMUM)
    
    slr_pulse returns a tuple of 4 items defined below:
        rf_waveform  - ndarray, complex, real/imag values of the rf_pulse.
        rf_xaxis     - ndarray, float, same size as rf_waveform contains 
                                the corresponding x axis points.
        gradient     - ndarray, float OR None
        grad_xaxis   - ndarray, float OR None

    May raise (or throw):
    
        TransformRunException - to indicate user calculated failure of 
                                algorithm or parameters

    Notes
    -----------------------------

    pulse_type - HYPERBOLIC_SECANT
    time_steps - Number of points
    quality_cycles - Number of cycles before truncating pulse.
    filter_type - ApodizationFilterType: 0-None, 1-Cosine, 2-Hamming
    filter_percent - How much to apply the filter (0.0 to 100.0)
    total_rotation - Total rotation angle in degrees (used for hyperbolic-secant).
    power_n - Power of hyperbolic secant function.
    sharpness_mu - Parameter that defines sharpness of function.
    dwell_time - The dwell time in microseconds.

    """
    param = trans_desc.parameters
    extra = trans_desc.extra

    #--------------------------------------------------------------------------
    # unpack and convert parameters if needed

    time_steps          = int(param["time_steps"])          # int
    duration            = float(param["duration"])          # float, msec
    total_rotation      = float(param["total_rotation"])    # float, degrees
    quality_cycles      = float(param["quality_cycles"])    # float
    power_n             = int(param["power_n"])             # int
    sharpness_mu        = float(param["sharpness_mu"])      # float
    filter_application  = float(param["filter_application"]) # float, %
    # Choice, 0-None, 1-Cosine, 2-Hamming
    filter_type         = int(param["filter_type"])         # int
    
    dwell_time          = (1000 * duration) / (time_steps)  # in usec
    dwell               = dwell_time / 1000000.0            # in sec
    
    # these extra items are used in making profile
    bandwidth_convention = int(extra['pulse_bandwidth_type'])  # Choice, 0-HalfHeight, 1-Min, 2-Max    
    resolution           = int(extra['calc_resolution']) # int
    gamma                = float(extra['gamma'])         # float MHz/T -&gt; 2pi * 100 -&gt; Hz/gauss


    #--------------------------------------------------------------------------
    # pulse creation code starts here

#     rf_y = analytic_pulse.hyperbolic_secant(time_points, cycles,
#                                 filter_type, filter_application, 
#                                 total_rotation, n, mu, dwell_time)
#
#     def hyperbolic_secant(nop, cycles, filter_type, filter_percent, angle, n, mu, dwell_time):
#         return analytic_pulse(pulse_type,nop,cycles,filter_type,filter_percent,angle,n,mu,dwell_time)
#    
#     def analytic_pulse(pulse_type, nop, cycles, filter_type, filter_percent, \
#                                        angle, n=1, mu=1, dwell_time=100):
    
    pulse_type = 3  #pf_constants.AnalyticType.HYPERBOLIC_SECANT:
    nop = time_steps
    cycles = quality_cycles
    angle = total_rotation
    n = power_n
    mu = sharpness_mu
    filter_percent = filter_application
    
    # Set local values
    
    g = np.ones(nop)
    y = g.copy()
    z = g.copy()
    
    # Determine whether nop even or odd (even = 1 or 0)
    if nop%2 == 0:
        even_flag = 1  
    else:
        even_flag = 0 
    
    # Generate symmetric sequence
    # starts at 0 for odd, at +1/2 for even
    if even_flag == 1:          
        # even_flag, starts at 1/2
        # matlab code; x = (1:nop/2) - 1/2
        x = np.arange(nop/2) + 1/2
    else:
        # odd, starts at 0
        # matlab code; x = (1:(nop+1)/2) -1
        x = np.arange((nop+1)/2)

    # HS pulse
    # sech(beta*t), where tmax = 1; so beta = cycles/2
    if n == 1:
        y = pow( math.pi*distributions.hypsecant.pdf(x*cycles/nop), complex(1, mu) ) 
    else:
        sqrtn = math.sqrt(n)
        s = (cycles/(sqrtn*nop))*x
        y = math.pi*distributions.hypsecant.pdf(s**n) 
    
        wfunct = lambda q: math.pi*distributions.hypsecant.pdf(q**n)**2
        
        w = np.zeros(len(s))
           
        for k in range(len(s)): 
            integral = integrate.quad(wfunct, 0, s[k])
            w[k] = integral[0]
            w[k] *= -mu*2.0*math.pi
             
        dphi = s[1]*w
        phi = dphi.cumsum(axis=0)
        
        y = y * np.exp(complex(0,1)*phi)
    
    # Note that beta, when n = 1, is cycles/2;
    # Gives width = mu*beta/pi = cycles*mu/pi
    
    if even_flag == 1:
        y = np.hstack([y[::-1], y]) 
    else:
        z = y.copy() 
        z = np.delete(z,0)
        y = np.hstack([z[::-1], y])
        
    # Check for apodization (Filter funct = g)
    # Then use apodization
    if not filter_type:
        z = y        
    else:
        z = filter_pulse(y, x, filter_type, filter_percent)

    z = scale_pulse(z, dwell_time, angle, pulse_type, gamma)    

    rf_waveform = z
    rf_xaxis = np.arange(time_steps) * dwell    # in sec
    
    gradient = None
    grad_xaxis = None
    
    #--------------------------------------------------------------------------
    # fill and output dictionary, if needed

    bandwidth = dwell_bandwidth_interconvert(dwell_time, sharpness_mu, quality_cycles, time_steps)
    outputs = {}
    outputs['out_bandwidth'] = bandwidth
    outputs['out_dwell_time'] = dwell_time

    #--------------------------------------------------------------------------
    # ensure you are returning ndarrays or None

    rf_y = np.array(rf_waveform)
    rf_x = np.array(rf_xaxis)
    gr_y = gradient
    gr_x = grad_xaxis

    return rf_y, rf_x, gr_y, gr_x, outputs
    
    
def scale_pulse(b1, dwell_time, angle, pulse_type, gamma):  

    # Scale b1 to requested angle.
    multiplier = 1000*(angle/360.0)
    if pulse_type == 3:  #pf_constants.AnalyticType.HYPERBOLIC_SECANT:
        sfact = np.sum(np.abs(b1))
    else:
        sfact = np.sum(b1)
    nfact = multiplier/(gamma * dwell_time * sfact) 
    return nfact*b1 


def filter_pulse(b1, xvals, filter_type, filter_percent):
    
    length = len(b1)
    if length%2 == 0:
        even_flag = 1  
    else:
        even_flag = 0     
    
    # seq to ~ pi/2 **    
    maxx = np.amax(xvals)
    f = (xvals*math.pi/maxx/2.0)*(filter_percent/100.0)

    # Cosine apodization
    if filter_type == 1:  #pf_constants.ApodizationFilterType.COSINE:   
        g = np.cos(f) 
    # Hamming apodization
    elif filter_type == 2:  #pf_constants.ApodizationFilterType.HAMMING:              
        g = 0.5*(1 - np.cos(math.pi+2*f)) 
    else:
        g = np.ones(len(f))

    if even_flag == 1:
        g = np.hstack([g[::-1], g]) 
    else:     
        h = g.copy() 
        h = np.delete(h,0)
        g = np.hstack([h[::-1], g]) 

    z = g*b1
    
    return z 


def dwell_bandwidth_interconvert(dtb, sharpness_mu, cycles, time_points):        
    # Note: dwell_time in microseconds and bandwidth in kHz.
    multiplier = sharpness_mu/math.pi
    return multiplier * cycles * 1000 / (time_points * dtb)  </algorithm_code>
				</transform_kernel>
				<transform_parameter version="1.0.0">
					<variable>time_steps</variable>
					<type>(Long)</type>
					<value>250</value>
				</transform_parameter>
				<transform_parameter version="1.0.0">
					<variable>duration</variable>
					<type>(Double)</type>
					<value>8.0</value>
				</transform_parameter>
				<transform_parameter version="1.0.0">
					<variable>total_rotation</variable>
					<type>(Double)</type>
					<value>1080.0</value>
				</transform_parameter>
				<transform_parameter version="1.0.0">
					<variable>quality_cycles</variable>
					<type>(Double)</type>
					<value>6.0</value>
				</transform_parameter>
				<transform_parameter version="1.0.0">
					<variable>power_n</variable>
					<type>(Long)</type>
					<value>1</value>
				</transform_parameter>
				<transform_parameter version="1.0.0">
					<variable>sharpness_mu</variable>
					<type>(Double)</type>
					<value>8.0</value>
				</transform_parameter>
				<transform_parameter version="1.0.0">
					<variable>filter_type</variable>
					<type>(Choice)</type>
					<value>0</value>
				</transform_parameter>
				<transform_parameter version="1.0.0">
					<variable>filter_application</variable>
					<type>(Double)</type>
					<value>0.0</value>
				</transform_parameter>
				<transform_parameter version="1.0.0">
					<variable>out_dwell_time</variable>
					<type>(Output)</type>
					<value>32.0</value>
				</transform_parameter>
				<transform_parameter version="1.0.0">
					<variable>out_bandwidth</variable>
					<type>(Output)</type>
					<value>1.909859317102744</value>
				</transform_parameter>
				<result version="1.0.0">
					<created>2021-03-07T13:33:51</created>
					<rf_waveform data_type="complex128" encoding="npy zlib base64">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</rf_waveform>
					<rf_xaxis data_type="float64" encoding="npy zlib base64">eNqdk/k31Wkcx9FpxkjSOCpGoaEbKVtKabwZkuRmyb5frutey3X3fZGRTKZJMjpOprQv6kSTGSUqpzjKmIaRtCqtU2nT0SKNZj5/wXx/ued+l+f5PO/367VldTQzPN7QQGagZrAzxRkixlI7xjKON8PFjsHJF0lELH5qvoid+el+ECtXnDl+X8xlCTLH/8/18HJzcXKx09r978vEgK6NTxtqRtoM8N+vOaLumgvFzlb03w7PuYMlDW8c6L4Tfkv1jXdPmk/P3YDazorLtzzovYXYNeedpmLqYnp/CSbuYmRGBvjQd9+AOzOaaS4Ffe8HTuhZ66wef1rnW0w3uWIW9CSA1gtER/uQkePEIFp3BdTrJo5MmBVM66+ES4DN4zuLQmifVbhp4HnrbFgo7cdEWcvKnhruato3DPa+dYOn/cJp/3C8rW5KdmVG0BwR6H7f1rc9PpLmiURtQneEGWcNzbUGRSduXNSKomi+KCTPeLT8qS6a5oyBl3z4dFJpDM0bC7PLH5d0bo2luePwYOGk4z574mj+eJzZMm1BbV08nSMBVS/tD1g3J9B5EiGKmD97Q0cinSsJIXXe1W97k+h8yfh6SuA03p1kOmcKRvPCyq4MpdB5U9HbmWAS/D6Vzp2GPkvP1mvfpdH50xBw3ltvYcKiHFiok/guW1XGojxYsHEIfFs4LZ1ySUdJz8pfT1anUz7peF0YJn45O4NyygDLI9rN+WAG5ZWBrtsJT1mubMqNjaWb0w5VNbApPzb2+XGy/vTJpBwzYfE8x+GL1kzKkwP9DuFtv2AO5crBk9Xy7YouDuWbhbgxTWJdVBblnIVzRwpnPLyaRXlz4Z5c0mvL4lLuXPxs+mN57AMu5c+DyaktYZvyeNQDD7KcKtP2VzzqIxuD1js6xpTZ1Es2wi7sKV5kkEP95KBJeSiAX5xDPeVgrlOdwT7TXOorFxVXGppvlOdSb7kwLGlSWVrlUX95yFt8djFzRx71mIf++23DRY586pOPoMrO+lO1fOqVj2PLu/nD7vnUbz5sX/fNc2nMp57z8e9jWwH1LcDowRfdzHQB9S7AsbWSet5eAfUvADd+ZNO6hwLiQIhZ7ir+znlC4kGIXuMPoc18IXEhROmAfl5/vZD4EMK/0cjk9bCQOBHh02rm3iLiRYQjWcbtLmoRcSMCG6V7g1tExI8I1tPNitiGYuJIjEtDZekFgWLiSYziNgv/6vVi4kqMZdsrbRsviIkvMV5JrcZ6JkuIMwkOMquvPwuXEG8SpDraNk2qkBB3Elh+2FnF6JMQfxJc/MtBEWAtJQ6lKDy8PyY1WUo8SuFd5OylrpESl1IMJR6x2DooJT5l2OPp9vLYHBlxKkPCpF8udfFkxKsMUwe9jv59WEbcytB+snHjZ89lxK8c2nKf3NmecuJYDs/slhBfmZx4luORv79Twgk5cS1HjdW5z2WjcuJbgZgXQfc3Q0GcK2Da0TH+qoJ4V6C1JnR3x3kFca+AQvHH2nvGSuJfCdfwyDTDUCV5oMQ9Rq/vzE1K8kGJbR9jZy7pVpIXSkT0XX0fZakiP1T4/GjyVUGcijxRoaV4oPGHbSryRQVJSsbWAzdV5I0azovuS8/Zq8kfNQYm86IG2GrySI3Ke489RverySc1mM38qTMeq8krDSb89OKZ5wIN+aXBiVxJV5hQQ55pkB84cjjnuIZ808DRRlW6fkRD3mlx/dUob/dSLfmnRflFffBprZY81CJ4txHj2hkt+ajFmOpT0DryUofjkcZ3v1yhIz91yHEubV2wQUee6mBvZLYz5Hcd+apDX3+ZnmOuJ2/12FhvkVK4Rk/+6hHwfeU40nryWI93aVZfnezXk896xNl0jWabFZDXBfAsmfLkjWsB+V0As+Hwa8URBfgH15mphQ==</rf_xaxis>
				</result>
			</transform>
		</pulse_design>
		<sequence_code>import pygamma as pg
import numpy as np
import math

def run(sim_desc):

    #----------------------------------------------------------------
    # This is an example PyGAMMA pulse sequence
    # for use in Vespa-Simulation
    #
    # A timing diagram for this pulse sequence can be
    # found in the Appendix of the Simulation User Manual.
    #----------------------------------------------------------------
    spin_system = sim_desc.spin_system

    # extract the dynamically changing variable
    # from loop 1 and 2 for 'te1' and 'te2', divide
    # by 1000.0 because the GUI states that values
    # are entered in [ms], but PyGAMMA wants [sec]
    #
    # evolution after 90 before first 180 in msec and
    # divide by 1000 so PyGAMMA TE is in msec
    
    te1 = sim_desc.dims[1]/1000.0
    te2 = sim_desc.dims[2]/1000.0
    
    # extract static RF pulses from the control dictionary. They are 
    # inserted into a list in the order that they are shown in the GUI.
    # The pulse name, dwell_time and waveform are all part of each 
    # MinimalPulse object in the list. Dwell_time is in micro-seconds,
    # so it needs to be converted to sec. Waveforms are the complex
    # time array that would be played out on MR scanner. These values
    # are complex numbers in mT, so taking the magnitude/phase of 
    # each waveform, we can convert these values into the Hz and phase
    # in degrees that a PulWaveform in PyGAMMA requires.
    
    pulsestep = sim_desc.pulses[0].dwell_time * 1e-6
    waveform  = sim_desc.pulses[0].waveform
    waveform  = np.array(waveform)
    # PulWaveform expects Hz amplitude and angle in degrees, while
    # Simulation gives us mT amplitude and angle in radians. 
    # We need to use the appropriate gyromagnetic ratio to do the 
    # conversion. This depends on our observe_isotope, since the pulse
    # is not isotope specific, but the spins we expect it to affect, is.
    # (e.g. we use 42576.0 for 1H to covert mT and RAD2DEG for phase)

    obs_iso = sim_desc.observe_isotope
    if obs_iso == '1H':
        gyratio = 42576.0
    elif obs_iso == '13C':
        gyratio = 67262.0
    elif obs_iso == '19F':
        gyratio = 251662.0
    elif obs_iso == '31P':
        gyratio = 108291.0

    ampl_arr  = np.abs(waveform) * gyratio
    phas_arr  = np.angle(waveform) * 180.0 / math.pi

    # set up a container and read pulse values into it. You could also
    # read a file using Python code and subsequently inset values into
    # the PyGAMMA row_vector container. Then create a time axis array
    # with a time value for each point in the pulse vector

    pulse = pg.row_vector(len(waveform))
    ptime = pg.row_vector(len(waveform))
    for j,val in enumerate(zip(ampl_arr,phas_arr)):
        pulse.put(pg.complex(val[0],val[1]), j)
        ptime.put(pg.complex(pulsestep,0), j)
    total = pulse.size() * pulsestep

    # create the pulse waveform and composite pulse objects from the
    # file and pulse sequence information
    
    pwf  = pg.PulWaveform(pulse, ptime, "adiabatic180")
    pulc = pg.PulComposite(pwf, spin_system, obs_iso)
    
    # note that below we have to now account for the time of
    # the pulse in our propagation intervals in order to have
    # our TE calculate correctly.
    
    H = pg.Hcs(spin_system) + pg.HJ(spin_system)
    D = pg.Fm(spin_system, obs_iso)
    Udelay1 = pg.prop(H, 0.5*(te1-total))
    Udelay2 = pg.prop(H, 0.5*(te1-total + te2-total))
    Udelay3 = pg.prop(H, 0.5*(te2-total))
    ac = pg.acquire1D(pg.gen_op(D), H, 0.001)
    ACQ = ac
    
    sigma0 = pg.sigma_eq(spin_system)
    sigma1 = pg.Iypuls(spin_system, sigma0, 90.0)
    sigma0 = pg.evolve(sigma1, Udelay1)
    Ureal180 = pulc.GetUsum(-1)
    sigma1 = Ureal180.evolve(sigma0)
    sigma0 = pg.evolve(sigma1, Udelay2)
    sigma1 = Ureal180.evolve(sigma0)
    sigma0 = pg.evolve(sigma1, Udelay3)
    
    # instantiate and save the transition table of simulation results
    # note. this step copies the TTable1D result from the ACQ into
    # a TTable1D object in the sim_desc object. Thus, when
    # we return from this function and the ACQ variable gets
    # garbage collected, our copy of the results in not affected
    
    sim_desc.mx = pg.TTable1D(ACQ.table(sigma0))
</sequence_code>
		<binning_code>import pygamma as pg
import numpy as np

def run(sim_desc):
    area   = pg.DoubleVector(0)
    ppm    = pg.DoubleVector(0)
    phase  = pg.DoubleVector(0)
    field  = sim_desc.field             # freq in MHz
    nspins = sim_desc.nspins
    tolppm = sim_desc.blend_tolerance_ppm
    tolpha = sim_desc.blend_tolerance_phase
    ppmlo  = sim_desc.peak_search_ppm_low
    ppmhi  = sim_desc.peak_search_ppm_high

    sys     = sim_desc.spin_system
    obs_iso = sim_desc.observe_isotope
    nlines  = sim_desc.mx.size()

    # Scaling is based on the quantum number of each spin, the qnStates.size
    # method sums 2*qn[i]+1 and then we divide by 2*qn[observe]+1 of the
    # observe spin.  This gets us back to the 'physics' norm where values are
    # =/- 1/2, so then we multiply by 2.0 to get values of 1.0 for each spin 
    # that is being normalized here.
    
    obs_qn  = pg.Isotope(obs_iso).qn()
    qnscale = sys.qnStates().size()
    qnscale = qnscale / (2.0 * (2.0*obs_qn+1))

    freqs = []
    outf  = []
    outa  = []
    outp  = []
    nbin  = 0
    found = False

    PI = 3.14159265358979323846
    RAD2DEG = 180.0/PI

    # Based on TTable1D::calc_spectra() ---------------------------------------

    indx = sim_desc.mx.Sort(0,-1,0)

    for i in range(nlines):
        freqs.append(-1 * sim_desc.mx.Fr(indx[i])/(2.0*PI*field))

    for i in range(nlines):
        freq = freqs[i]
        if (freq &gt; ppmlo) and (freq &lt; ppmhi):
            val = sim_desc.mx.I(indx[i])
            tmpa = np.sqrt(val.real()**2 + val.imag()**2) / qnscale  #normal
            tmpp = -RAD2DEG * np.angle(val.real()+1j*val.imag())

        if nbin == 0:
            outf.append(freq)
            outa.append(tmpa)
            outp.append(tmpp)
            nbin += 1
        else:
            for k in range(nbin):
                if (freq &gt;= outf[k]-tolppm) and (freq &lt;= outf[k]+tolppm):
                    if (tmpp &gt;= outp[k]-tolpha) and (tmpp &lt;= outp[k]+tolpha):
                        ampsum   =  outa[k]+tmpa
                        outf[k]  = (outa[k]*outf[k] + tmpa*freq)/ampsum
                        outp[k]  = (outa[k]*outp[k] + tmpa*tmpp)/ampsum
                        outa[k] +=  tmpa;
                        found = True
            if not found:
                outf.append(freq)
                outa.append(tmpa)
                outp.append(tmpp)
                nbin += 1
            found = False

    ppm.resize(nbin)
    area.resize(nbin)
    phase.resize(nbin)

    for i in range(nbin):
        ppm[i]   = outf[i]
        area[i]  = outa[i]
        phase[i] = -1.0*outp[i]

    return (ppm, area, phase)
        </binning_code>
	</pulse_sequence>
	<pulse_sequence id="68ca6a47-d983-4819-859e-42d43cbjs100" version="1.0.0">
		<name>STEAM Ideal</name>
		<created>2021-03-03T20:39:02</created>
		<creator>Brian Soher</creator>
		<comment>This is an example PyGAMMA pulse sequence for use in Vespa-Simulation

A timing diagram for this pulse sequence can be found in the Appendix of the Simulation User Manual.

Fixes to previous versions. This version still zeros the 2nd order coherences with zero_mqc(), but 
leaves the 0th and 1st order alone. It also performs the 'crusher'/dephase operation properly on 
only the 2nd and 3rd 90 pulses.  
</comment>
		<loop_label>TE [ms]</loop_label>
		<loop_label>TM [ms]</loop_label>
		<sequence_code>import pygamma as pg


def run(sim_desc):
    #------------------------------------------------------------------------
    # This is an example PyGAMMA pulse sequence for use in Vespa-Simulation
    #
    # A timing diagram for this pulse sequence can be found in the Appendix 
    # of the Simulation User Manual.
    #------------------------------------------------------------------------
    spin_system = sim_desc.spin_system

    # the isotope string used to sort/select the metabolites of interest is passed 
    # in the sim_desc object so the user can tailor other object within their 
    # code to be nuclei specific, such as the observe operator or pulses
    obs_iso = sim_desc.observe_isotope

    # extract the dynamically changing variable from loops 1 and 2 for 'te'
    # and 'tm', divide by 1000.0 because the GUI states that values are 
    # entered in [ms], but PyGAMMA wants [sec]

    te = sim_desc.dims[1] / 1000.0
    tm = sim_desc.dims[2] / 1000.0

    # set up steady state and observation variables
    H   = pg.Hcs(spin_system) + pg.HJ(spin_system) 
    D   = pg.Fm(spin_system, obs_iso) 
    ac  = pg.acquire1D(pg.gen_op(D), H, 0.000001) 
    ACQ = ac 

    # excite, propagate, refocus and acquire the data
    #
    # for the case of STEAM, we need to simulate crusher gradients around the 
    # second and third 90 pulses. We do this by creating 4 copies of the 
    # operator matrix at that point, rotate respectively  by 0, 90, 180 and 270 
    # degrees to each other, apply the 90 pulses and TM period, and then 
    # add the four back into one normalized matrix. 

    dephase_ang = [ 0.0, 90.0, 180.0, 270.0 ]
    Udelay1     = pg.prop(H, te*0.5)
    Udelay2     = pg.prop(H, tm)

    sigma0  = pg.sigma_eq(spin_system)
    # first 90 pulse, excite spins
    sigma0  = pg.Iypuls(spin_system, sigma0, obs_iso, 90.0)
    # nutate TE/2
    sigma0  = pg.evolve(sigma0, Udelay1)

    # Now we need to create the effect of crushers around the 2nd and 3rd 
    # 90 pulses. This is done by creating 4 copies of spin state and repeating
    # the rest of the sequence for four different rotations around z-axis
    sigma_mult  = []
    for i in dephase_ang:
        sigma_mult.append(pg.gen_op(sigma0))

    for i, angle in enumerate(dephase_ang):
        # calculate and apply rotation around z-axis
        riz = pg.gen_op(pg.Rz(spin_system, angle))
        sigma_mult[i] = pg.evolve( sigma_mult[i], riz )

        # second 90 pulse
        sigma_mult[i] = pg.Ixpuls(spin_system, sigma_mult[i], obs_iso, 90.0)
        
        # this function removes all coherences still in transverse plane
        # this removes all 2nd order stimulated echos from first and second 90 pulse
        pg.zero_mqc(spin_system, sigma_mult[i], 2, 0 )
        
        # this line evolves signals for TM period
        sigma_mult[i] = pg.evolve(sigma_mult[i], Udelay2)

        # third 90 pulse
        sigma_mult[i] = pg.Ixpuls(spin_system, sigma_mult[i], obs_iso, 90.0)
        
        # undo rotation around z-axis
        sigma_mult[i] = pg.evolve( sigma_mult[i], riz )
        
        # scale results based on the number of phase angles
        sigma_mult[i] *= 1.0/float(len(dephase_ang))
        
        # sum up each rotated/unrotated results
        if i == 0:
            sigma_res = pg.gen_op(sigma_mult[i])
        else:
            sigma_res += sigma_mult[i]

    # last TE/2 nutation
    sigma0 = pg.evolve(sigma_res, Udelay1)

    # instantiate and save transition table of simulation results
    # note. this step copies the TTable1D result from the ACQ into
    #       a TTable1D object in the sim_desc object. Thus, when
    #       we return from this function and the ACQ variable gets
    #       garbage collected, our copy of the results in not affected
    sim_desc.mx = pg.TTable1D(ACQ.table(sigma0))
</sequence_code>
		<binning_code>import pygamma as pg
import numpy as np

def run(sim_desc):
    area   = pg.DoubleVector(0)
    ppm    = pg.DoubleVector(0)
    phase  = pg.DoubleVector(0)
    field  = sim_desc.field             # freq in MHz
    nspins = sim_desc.nspins
    tolppm = sim_desc.blend_tolerance_ppm
    tolpha = sim_desc.blend_tolerance_phase
    ppmlo  = sim_desc.peak_search_ppm_low
    ppmhi  = sim_desc.peak_search_ppm_high

    sys     = sim_desc.spin_system
    obs_iso = sim_desc.observe_isotope
    nlines  = sim_desc.mx.size()

    # Scaling is based on the quantum number of each spin, the qnStates.size
    # method sums 2*qn[i]+1 and then we divide by 2*qn[observe]+1 of the
    # observe spin.  This gets us back to the 'physics' norm where values are
    # =/- 1/2, so then we multiply by 2.0 to get values of 1.0 for each spin 
    # that is being normalized here.
    
    obs_qn  = pg.Isotope(obs_iso).qn()
    qnscale = sys.qnStates().size()
    qnscale = qnscale / (2.0 * (2.0*obs_qn+1))

    freqs = []
    outf  = []
    outa  = []
    outp  = []
    nbin  = 0
    found = False

    PI = 3.14159265358979323846
    RAD2DEG = 180.0/PI

    # Based on TTable1D::calc_spectra() ---------------------------------------

    indx = sim_desc.mx.Sort(0,-1,0)

    for i in range(nlines):
        freqs.append(-1 * sim_desc.mx.Fr(indx[i])/(2.0*PI*field))

    for i in range(nlines):
        freq = freqs[i]
        if (freq &gt; ppmlo) and (freq &lt; ppmhi):
            val = sim_desc.mx.I(indx[i])
            tmpa = np.sqrt(val.real()**2 + val.imag()**2) / qnscale  #normal
            tmpp = -RAD2DEG * np.angle(val.real()+1j*val.imag())

        if nbin == 0:
            outf.append(freq)
            outa.append(tmpa)
            outp.append(tmpp)
            nbin += 1
        else:
            for k in range(nbin):
                if (freq &gt;= outf[k]-tolppm) and (freq &lt;= outf[k]+tolppm):
                    if (tmpp &gt;= outp[k]-tolpha) and (tmpp &lt;= outp[k]+tolpha):
                        ampsum   =  outa[k]+tmpa
                        outf[k]  = (outa[k]*outf[k] + tmpa*freq)/ampsum
                        outp[k]  = (outa[k]*outp[k] + tmpa*tmpp)/ampsum
                        outa[k] +=  tmpa;
                        found = True
            if not found:
                outf.append(freq)
                outa.append(tmpa)
                outp.append(tmpp)
                nbin += 1
            found = False

    ppm.resize(nbin)
    area.resize(nbin)
    phase.resize(nbin)

    for i in range(nbin):
        ppm[i]   = outf[i]
        area[i]  = outa[i]
        phase[i] = -1.0*outp[i]

    return (ppm, area, phase)
</binning_code>
	</pulse_sequence>
	<pulse_sequence id="69888594-2ff1-4e63-b86c-735480bjs100" version="1.0.0">
		<name>Spin-Echo</name>
		<created>2021-03-07T20:47:37</created>
		<creator>Brian Soher</creator>
		<comment>This is an example PyGAMMA pulse sequence for use in Vespa-Simulation

A timing diagram for this pulse sequence can be found in the Appendix of the Simulation User Manual.
</comment>
		<loop_label>TE [ms]</loop_label>
		<sequence_code>import pygamma as pg

def run(sim_desc):
    #-----------------------------------------------------------------------
    # This is an example PyGAMMA pulse sequence for use in Vespa-Simulation
    #
    # A timing diagram for this pulse sequence can be found in the Appendix 
    # of the Simulation User Manual.
    #-----------------------------------------------------------------------
    spin_system = sim_desc.spin_system

    # the isotope string used to sort/select the metabolites of interest is passed 
    # in the sim_desc object so the user can tailor other object within their 
    # code to be nuclei specific, such as the observe operator or pulses
    obs_iso = sim_desc.observe_isotope

    # extract the dynamically changing variable from loop 1 for 'te', divide
    # by 1000.0 because the GUI states that values are entered in [ms], but 
    # PyGAMMA wants [sec]

    te1 = sim_desc.dims[1] / 1000.0  

    # set up steady state and observation variables
    H   = pg.Hcs(spin_system) + pg.HJ(spin_system) 
    D   = pg.Fm(spin_system, obs_iso) 
    ac  = pg.acquire1D(pg.gen_op(D), H, 0.000001) 
    ACQ = ac 
    sigma0 = pg.sigma_eq(spin_system) 

    # excite, propagate, refocus and acquire the data
    sigma1 = pg.Iypuls(spin_system, sigma0, obs_iso, -90.0)
    Udelay = pg.prop(H, te1*0.5)
    sigma0 = pg.evolve(sigma1, Udelay)
    sigma1 = pg.Iypuls(spin_system, sigma0, obs_iso, 180.0)
    Udelay = pg.prop(H, te1*0.5)
    sigma0 = pg.evolve(sigma1, Udelay)

    # instantiate and save the transition table of simulation results
    # note. this step copies the TTable1D result from the ACQ into
    #       a TTable1D object in the sim_desc object. Thus, when
    #       we return from this function and the ACQ variable gets
    #       garbage collected, our copy of the results in not affected
    sim_desc.mx = pg.TTable1D(ACQ.table(sigma0))
</sequence_code>
		<binning_code>import pygamma as pg
import numpy as np

def run(sim_desc):
    area   = pg.DoubleVector(0)
    ppm    = pg.DoubleVector(0)
    phase  = pg.DoubleVector(0)
    field  = sim_desc.field             # freq in MHz
    nspins = sim_desc.nspins
    tolppm = sim_desc.blend_tolerance_ppm
    tolpha = sim_desc.blend_tolerance_phase
    ppmlo  = sim_desc.peak_search_ppm_low
    ppmhi  = sim_desc.peak_search_ppm_high

    sys     = sim_desc.spin_system
    obs_iso = sim_desc.observe_isotope
    nlines  = sim_desc.mx.size()

    # Scaling is based on the quantum number of each spin, the qnStates.size
    # method sums 2*qn[i]+1 and then we divide by 2*qn[observe]+1 of the
    # observe spin.  This gets us back to the 'physics' norm where values are
    # =/- 1/2, so then we multiply by 2.0 to get values of 1.0 for each spin 
    # that is being normalized here.
    
    obs_qn  = pg.Isotope(obs_iso).qn()
    qnscale = sys.qnStates().size()
    qnscale = qnscale / (2.0 * (2.0*obs_qn+1))

    freqs = []
    outf  = []
    outa  = []
    outp  = []
    nbin  = 0
    found = False

    PI = 3.14159265358979323846
    RAD2DEG = 180.0/PI

    # Based on TTable1D::calc_spectra() ---------------------------------------

    indx = sim_desc.mx.Sort(0,-1,0)

    for i in range(nlines):
        freqs.append(-1 * sim_desc.mx.Fr(indx[i])/(2.0*PI*field))

    for i in range(nlines):
        freq = freqs[i]
        if (freq &gt; ppmlo) and (freq &lt; ppmhi):
            val = sim_desc.mx.I(indx[i])
            tmpa = np.sqrt(val.real()**2 + val.imag()**2) / qnscale  #normal
            tmpp = -RAD2DEG * np.angle(val.real()+1j*val.imag())

        if nbin == 0:
            outf.append(freq)
            outa.append(tmpa)
            outp.append(tmpp)
            nbin += 1
        else:
            for k in range(nbin):
                if (freq &gt;= outf[k]-tolppm) and (freq &lt;= outf[k]+tolppm):
                    if (tmpp &gt;= outp[k]-tolpha) and (tmpp &lt;= outp[k]+tolpha):
                        ampsum   =  outa[k]+tmpa
                        outf[k]  = (outa[k]*outf[k] + tmpa*freq)/ampsum
                        outp[k]  = (outa[k]*outp[k] + tmpa*tmpp)/ampsum
                        outa[k] +=  tmpa;
                        found = True
            if not found:
                outf.append(freq)
                outa.append(tmpa)
                outp.append(tmpp)
                nbin += 1
            found = False

    ppm.resize(nbin)
    area.resize(nbin)
    phase.resize(nbin)

    for i in range(nbin):
        ppm[i]   = outf[i]
        area[i]  = outa[i]
        phase[i] = -1.0*outp[i]

    return (ppm, area, phase)
</binning_code>
	</pulse_sequence>
</vespa_export>